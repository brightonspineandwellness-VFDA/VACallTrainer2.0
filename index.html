<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Virtual Front Desk Academy Trainer</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        .container {
            max-width: 900px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        .header h1 { font-size: 28px; margin-bottom: 10px; }
        .header p { opacity: 0.9; font-size: 16px; }
        .content { padding: 40px; }
        .form-group { margin-bottom: 20px; }
        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #333;
        }
        .form-group input {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            font-size: 16px;
            transition: border-color 0.3s;
        }
        .form-group input:focus {
            outline: none;
            border-color: #667eea;
        }
        .form-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }
        .difficulty-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin-bottom: 30px;
        }
        .difficulty-btn {
            padding: 20px;
            border: 3px solid #e0e0e0;
            border-radius: 15px;
            background: white;
            cursor: pointer;
            text-align: center;
            transition: all 0.3s;
        }
        .difficulty-btn:hover { border-color: #667eea; transform: translateY(-2px); }
        .difficulty-btn.selected { background: #667eea; color: white; border-color: #667eea; }
        .start-btn {
            width: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 50px;
            border-radius: 30px;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
        }
        .start-btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .chat-container {
            background: #f5f5f5;
            border-radius: 15px;
            padding: 20px;
            max-height: 350px;
            overflow-y: auto;
            margin-bottom: 20px;
        }
        .message {
            margin-bottom: 15px;
            padding: 12px 18px;
            border-radius: 15px;
            max-width: 80%;
        }
        .message.staff { background: #667eea; color: white; margin-left: auto; }
        .message.patient { background: white; border: 1px solid #ddd; }
        .message.system { background: #ffc107; text-align: center; max-width: 100%; }
        .end-call-btn {
            width: 100%;
            background: #dc3545;
            color: white;
            border: none;
            padding: 15px;
            border-radius: 10px;
            font-size: 16px;
            cursor: pointer;
        }
        .score-card { background: #f9f9f9; border-radius: 15px; padding: 25px; }
        .overall-score {
            font-size: 64px;
            font-weight: bold;
            text-align: center;
            margin-bottom: 30px;
        }
        .score-item {
            background: white;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 10px;
        }
        .status-box {
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            text-align: center;
            font-weight: bold;
        }
        .status-listening { background: #e8f5e9; color: #2e7d32; }
        .status-speaking { background: #e3f2fd; color: #1565c0; }
        .status-thinking { background: #fff3e0; color: #ef6c00; }
        .feedback-section {
            margin-top: 20px;
            padding: 15px;
            background: white;
            border-radius: 10px;
        }
        .feedback-section h4 { margin-bottom: 10px; color: #333; }
        .feedback-section ul { margin-left: 20px; }
        .feedback-section li { margin-bottom: 5px; }
        .positive { color: #2e7d32; }
        .negative { color: #c62828; }
        .critical { color: #d32f2f; font-weight: bold; }
    </style>
</head>
<body>
    <div id="root"></div>
    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // INDIVIDUAL PASSWORD SYSTEM
        // Add new VA passwords here in the format: "password": "VA Name"
        const AUTHORIZED_USERS = {
            "VFDA2025": "Demo User",
            "VFDA-SARAH-2025": "Sarah Johnson",
            "VFDA-MIKE-2025": "Mike Davis",
            "VFDA-EMMA-2025": "Emma Wilson",
            "VFDA-ALEX-2025": "Alex Rodriguez",
            "VFDA-MELLE-2025": "Melle Antoiniette Puyot",
            // Add more passwords below as needed:
            // "VFDA-NAME-2025": "Full Name",
        };

        const STORED_KEY = localStorage.getItem('openai_api_key');
        const STORED_VA_NAME = localStorage.getItem('va_name');
        const STORED_PASSWORD = localStorage.getItem('user_password');

        // Patient personas - OUTSIDE component to avoid closure issues
        const PATIENT_PERSONAS = {
            easy: {
                name: 'Sarah Johnson',
                phone: '555-867-5309',
                email: 'sarah.johnson@email.com',
                problem: 'back pain for about 2 weeks',
                availability: 'this week, mornings are best',
                referral: 'a friend recommended you'
            },
            challenging: {
                name: 'Mike Davis',
                phone: '555-234-5678',
                email: 'mike.davis@email.com',
                problem: 'neck pain and stiffness',
                availability: 'flexible, any day works',
                referral: 'found you on Google',
                insurance: 'Blue Cross Blue Shield'
            }
        };

        // Insurance companies for random selection
        const INSURANCE_COMPANIES = [
            'Blue Cross Blue Shield',
            'Aetna',
            'UnitedHealthcare',
            'Cigna'
        ];

        // Insurance Triad - Always asked as a sequence of 3
        const INSURANCE_TRIAD = [
            {
                id: 'insurance_q1',
                question: 'Do you take insurance?',
                checkAnswer: (vaText) => vaText.includes('program') || vaText.includes('work with') || vaText.includes('all') || vaText.includes('accept') || vaText.includes('yes')
            },
            {
                id: 'insurance_q2',
                getQuestion: (insuranceName) => `I just want to make sure my ${insuranceName} insurance is covered`,
                checkAnswer: (vaText) => vaText.includes('patient') || vaText.includes('care') || vaText.includes('receiving') || vaText.includes('work with') || vaText.includes('covered')
            },
            {
                id: 'insurance_q3',
                question: "Well, doesn't my insurance cover anything?",
                checkAnswer: (vaText) => vaText.includes('bring') || vaText.includes('card') || vaText.includes('verify') || vaText.includes('coverage') || vaText.includes('first visit')
            }
        ];

        // Other questions for challenging mode
        const OTHER_QUESTIONS = [
            {
                id: 'cost',
                question: 'How much does the first visit cost?',
                checkAnswer: (vaText) => vaText.includes('$') || vaText.includes('dollar') || vaText.includes('49') || vaText.includes('59') || vaText.match(/\d+/) || vaText.includes('varies') || vaText.includes('discuss')
            },
            {
                id: 'duration',
                question: 'How long does the appointment usually take?',
                checkAnswer: (vaText) => vaText.includes('30') || vaText.includes('45') || vaText.includes('minute') || vaText.includes('hour')
            },
            {
                id: 'bring',
                question: 'What do I need to bring?',
                checkAnswer: (vaText) => vaText.includes('bring') || vaText.includes('insurance card') || vaText.includes('x-ray') || vaText.includes('mri') || vaText.includes('id')
            },
            {
                id: 'includes',
                question: 'What does the first visit include?',
                checkAnswer: (vaText) => vaText.includes('consultation') || vaText.includes('exam') || vaText.includes('adjustment') || vaText.includes('include')
            }
        ];

        // Helper function to select random questions for challenging mode
        // Pattern 1: Insurance Triad (3 questions)
        // Pattern 2: 1 Random Other Question
        // Pattern 3: 1-2 Random Other Questions
        function selectRandomQuestions() {
            const pattern = Math.floor(Math.random() * 3); // 0, 1, or 2
            
            if (pattern === 0) {
                // Pattern 1: Insurance Triad
                const randomInsurance = INSURANCE_COMPANIES[Math.floor(Math.random() * INSURANCE_COMPANIES.length)];
                return {
                    type: 'insurance_triad',
                    insuranceName: randomInsurance,
                    questions: INSURANCE_TRIAD,
                    totalQuestions: 3
                };
            } else if (pattern === 1) {
                // Pattern 2: 1 Random Other Question
                const shuffled = [...OTHER_QUESTIONS].sort(() => Math.random() - 0.5);
                return {
                    type: 'other_questions',
                    questions: [shuffled[0]],
                    totalQuestions: 1
                };
            } else {
                // Pattern 3: 1-2 Random Other Questions
                const numQuestions = Math.random() < 0.5 ? 1 : 2;
                const shuffled = [...OTHER_QUESTIONS].sort(() => Math.random() - 0.5);
                return {
                    type: 'other_questions',
                    questions: shuffled.slice(0, numQuestions),
                    totalQuestions: numQuestions
                };
            }
        }

        // Helper function to check if VA response indicates call ending
        function isGoodbyePhrase(text) {
            const lower = text.toLowerCase();
            const goodbyePhrases = [
                'goodbye',
                'bye bye',
                'see you',
                'have a great day',
                'have a nice day',
                'talk to you later',
                'thank you, bye'
            ];
            
            return goodbyePhrases.some(phrase => lower.includes(phrase));
        }

        // Helper function to generate patient goodbye response
        function getPatientGoodbye() {
            const goodbyes = [
                'Goodbye!',
                'Thank you!',
                'Thank you, goodbye!',
                'Perfect, thank you, bye!',
                'Great, thank you, bye!',
                'Sounds good, goodbye!'
            ];
            
            return goodbyes[Math.floor(Math.random() * goodbyes.length)];
        }

        function ChiroVoiceTrainer() {
            const [isAuthenticated, setIsAuthenticated] = useState(sessionStorage.getItem('auth') === 'true');
            const [passwordInput, setPasswordInput] = useState('');
            const [passwordError, setPasswordError] = useState('');
            const [apiKey, setApiKey] = useState(STORED_KEY || '');
            const [showApiPrompt, setShowApiPrompt] = useState(!STORED_KEY);
            const [gameState, setGameState] = useState('setup');
            
            // Form fields
            const [officeName, setOfficeName] = useState('');
            const [doctorName, setDoctorName] = useState('');
            const [firstVisitCost, setFirstVisitCost] = useState('');
            const [vaName, setVaName] = useState(STORED_VA_NAME || '');
            const [currentVAName, setCurrentVAName] = useState(STORED_VA_NAME || '');
            
            const [difficulty, setDifficulty] = useState('');
            const [messages, setMessages] = useState([]);
            const [currentStatus, setCurrentStatus] = useState('idle');
            const [scoreData, setScoreData] = useState(null);
            const [interimText, setInterimText] = useState('');
            const [callStartTime, setCallStartTime] = useState(null);
            const [callEndTime, setCallEndTime] = useState(null);

            // Use REFS for values needed in async callbacks to avoid stale closures
            const conversationRef = useRef([]);
            const difficultyRef = useRef('');
            const apiKeyRef = useRef('');
            const officeNameRef = useRef('');
            const doctorNameRef = useRef('');
            const firstVisitCostRef = useRef('');
            const selectedQuestionsRef = useRef([]);
            
            const recognitionRef = useRef(null);
            const shouldListenRef = useRef(false);
            const isProcessingRef = useRef(false);
            const silenceTimerRef = useRef(null);
            const lastTranscriptRef = useRef('');
            const audioRef = useRef(null);
            const callEndingRef = useRef(false);

            // Keep refs in sync with state
            useEffect(() => { difficultyRef.current = difficulty; }, [difficulty]);
            useEffect(() => { apiKeyRef.current = apiKey; }, [apiKey]);
            useEffect(() => { officeNameRef.current = officeName; }, [officeName]);
            useEffect(() => { doctorNameRef.current = doctorName; }, [doctorName]);
            useEffect(() => { firstVisitCostRef.current = firstVisitCost; }, [firstVisitCost]);

            const checkPassword = () => {
                const trimmedPassword = passwordInput.trim();
                
                // Check if password exists in authorized users
                if (AUTHORIZED_USERS[trimmedPassword]) {
                    const vaNameFromPassword = AUTHORIZED_USERS[trimmedPassword];
                    
                    // Store authentication and VA info
                    sessionStorage.setItem('auth', 'true');
                    localStorage.setItem('va_name', vaNameFromPassword);
                    localStorage.setItem('user_password', trimmedPassword);
                    
                    // Track first login time
                    if (!localStorage.getItem('first_login_' + trimmedPassword)) {
                        localStorage.setItem('first_login_' + trimmedPassword, new Date().toISOString());
                    }
                    localStorage.setItem('last_login_' + trimmedPassword, new Date().toISOString());
                    
                    setCurrentVAName(vaNameFromPassword);
                    setVaName(vaNameFromPassword);
                    setIsAuthenticated(true);
                } else {
                    setPasswordError('Invalid access code. Please check and try again.');
                    setPasswordInput('');
                }
            };

            const saveApiKey = () => {
                localStorage.setItem('openai_api_key', apiKey);
                setShowApiPrompt(false);
            };

            // Generate phone ring sound
            const playPhoneRing = async () => {
                return new Promise((resolve) => {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const duration = 2; // 2 seconds of ringing
                    
                    // Create oscillators for ring tone (440Hz and 480Hz)
                    const osc1 = audioContext.createOscillator();
                    const osc2 = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    osc1.connect(gainNode);
                    osc2.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    osc1.frequency.value = 440;
                    osc2.frequency.value = 480;
                    gainNode.gain.value = 0.3;
                    
                    // Ring pattern: on for 0.4s, off for 0.2s, repeat
                    const now = audioContext.currentTime;
                    for (let i = 0; i < 3; i++) {
                        const startTime = now + (i * 0.6);
                        gainNode.gain.setValueAtTime(0.3, startTime);
                        gainNode.gain.setValueAtTime(0, startTime + 0.4);
                    }
                    
                    osc1.start(now);
                    osc2.start(now);
                    osc1.stop(now + duration);
                    osc2.stop(now + duration);
                    
                    setTimeout(() => {
                        resolve();
                    }, duration * 1000);
                });
            };

            // Build prompt based on difficulty and conversation
            const buildPrompt = () => {
                const diff = difficultyRef.current;
                const conversation = conversationRef.current;
                const persona = PATIENT_PERSONAS[diff] || PATIENT_PERSONAS.easy;
                
                console.log('=== BUILD PROMPT ===');
                console.log('Difficulty from ref:', diff);
                console.log('Persona:', persona);
                
                // Build conversation text
                let convoText = conversation.map(m => `${m.speaker}: ${m.text}`).join('\n');
                
                // Count patient turns
                const patientTurns = conversation.filter(m => m.speaker === 'PATIENT').length;
                const isFirstResponse = patientTurns === 0;

                // Check if VA just said goodbye
                const lastVAMessage = conversation.length > 0 && conversation[conversation.length - 1].speaker === 'VA' 
                    ? conversation[conversation.length - 1].text 
                    : '';
                
                if (isGoodbyePhrase(lastVAMessage)) {
                    return `You are ending a phone call. The receptionist just said goodbye to you.

Respond with ONLY one of these goodbye phrases:
- "Goodbye!"
- "Thank you!"
- "Thank you, goodbye!"
- "Perfect, thank you, bye!"

Pick one randomly. Say nothing else. No additional text.`;
                }

                // ==================== EASY MODE ====================
                if (diff === 'easy') {
                    if (isFirstResponse) {
                        return `You are Sarah Johnson, calling a chiropractic office to book an appointment for back pain.

The receptionist just answered. Say you want to schedule an appointment.

Say exactly: "Hi, I'd like to schedule an appointment. I've been having some back pain for about 2 weeks."`;
                    }

                    // Detect what information VA is REQUESTING (not just mentioning)
                    // Only respond with info if VA is ASKING for it, not just confirming/informing
                    const lastVAMessage = conversation.length > 0 && conversation[conversation.length - 1].speaker === 'VA' 
                        ? conversation[conversation.length - 1].text.toLowerCase()
                        : '';
                    
                    // Check for SPECIFIC TIME SLOTS FIRST (highest priority)
                    const timeSlotPattern = /(\d{1,2})\s*(am|pm|a\.m|p\.m)/gi;
                    const timeMatches = lastVAMessage.match(timeSlotPattern);
                    
                    if (timeMatches && timeMatches.length >= 2) {
                        // VA offered multiple time slots - pick one randomly
                        const randomTime = timeMatches[Math.floor(Math.random() * timeMatches.length)];
                        return `The VA just offered you multiple appointment times. Pick ONE specific time.

CONVERSATION SO FAR:
${convoText}

The VA's last message mentioned these times: ${timeMatches.join(', ')}

Pick ONE time randomly and respond with ONLY that choice.

Examples of good responses:
- "${randomTime} works great for me"
- "I'll take ${randomTime}"
- "${randomTime} is perfect"
- "Let's do ${randomTime}"

Pick one of these response styles randomly. Say nothing else.`;
                    }
                    
                    // Check if VA is offering CHOICES (A or B) - patient should pick one
                    const askingMorningOrAfternoon = lastVAMessage.includes('morning') && lastVAMessage.includes('afternoon') && lastVAMessage.includes(' or ');
                    const askingEarlyOrLate = (lastVAMessage.includes('early') || lastVAMessage.includes('earlier')) && (lastVAMessage.includes('late') || lastVAMessage.includes('later')) && lastVAMessage.includes(' or ');
                    
                    // If VA is asking patient to choose between time options, handle that
                    if (askingMorningOrAfternoon) {
                        const choice = Math.random() < 0.5 ? 'morning' : 'afternoon';
                        return `The VA is asking if you prefer morning or afternoon.

Pick ONE randomly and respond naturally.

Examples:
- "${choice.charAt(0).toUpperCase() + choice.slice(1)} works better for me"
- "I'd prefer ${choice}"
- "${choice.charAt(0).toUpperCase() + choice.slice(1)} is best"
- "Let's do ${choice}"

Pick one response style randomly. Say nothing else.`;
                    }
                    
                    if (askingEarlyOrLate) {
                        const choice = Math.random() < 0.5 ? 'this week' : 'next week';
                        return `The VA is asking if you prefer early or later in the week.

Pick ONE randomly and respond naturally.

Examples:
- "This week works better for me"
- "I'd prefer earlier this week"
- "Later in the week is best"

Pick one response style randomly. Say nothing else.`;
                    }
                    
                    const askingForEmail = (
                        (lastVAMessage.includes('email') && 
                        (lastVAMessage.includes('can i have') || 
                         lastVAMessage.includes('what is') || 
                         lastVAMessage.includes('what\'s') ||
                         lastVAMessage.includes('whats') ||
                         lastVAMessage.includes('may i have') ||
                         lastVAMessage.includes('i need') ||
                         lastVAMessage.includes('give me') ||
                         lastVAMessage.includes('send to') ||
                         lastVAMessage.includes('best email') ||
                         lastVAMessage.includes('your email'))) &&
                        !lastVAMessage.includes('sending') &&
                        !lastVAMessage.includes('send it to') &&
                        !lastVAMessage.includes('will send') &&
                        !lastVAMessage.includes('i\'ll send')
                    );
                    
                    const askingForPhone = (
                        (lastVAMessage.includes('phone') || lastVAMessage.includes('number')) && 
                        (lastVAMessage.includes('can i have') || 
                         lastVAMessage.includes('what is') || 
                         lastVAMessage.includes('what\'s') ||
                         lastVAMessage.includes('whats') ||
                         lastVAMessage.includes('may i have') ||
                         lastVAMessage.includes('i need') ||
                         lastVAMessage.includes('give me') ||
                         lastVAMessage.includes('best number') ||
                         lastVAMessage.includes('your phone') ||
                         lastVAMessage.includes('your number'))
                    );
                    
                    const askingForName = (
                        lastVAMessage.includes('name') && 
                        !askingForEmail && 
                        !askingForPhone &&
                        (lastVAMessage.includes('can i have') || 
                         lastVAMessage.includes('what is') || 
                         lastVAMessage.includes('what\'s') ||
                         lastVAMessage.includes('whats') ||
                         lastVAMessage.includes('may i have') ||
                         lastVAMessage.includes('i need') ||
                         lastVAMessage.includes('give me') ||
                         lastVAMessage.includes('full name') ||
                         lastVAMessage.includes('your name'))
                    );
                    
                    const askingForReferral = lastVAMessage.includes('hear about') || lastVAMessage.includes('find us') || lastVAMessage.includes('how did you');
                    
                    // Check if VA is asking for referral follow-up (who referred you)
                    // First check if patient already said "friend" in any previous message
                    const patientMessages = conversation.filter(m => m.speaker === 'PATIENT');
                    const patientSaidFriend = patientMessages.some(m => m.text.toLowerCase().includes('friend'));
                    
                    // Then check if VA is now asking WHO that friend is
                    const askingWhoReferred = patientSaidFriend && (
                        lastVAMessage.includes('who') || 
                        lastVAMessage.includes('who referred') || 
                        lastVAMessage.includes('what is their name') || 
                        lastVAMessage.includes('friend\'s name') ||
                        lastVAMessage.includes('name of your friend') ||
                        lastVAMessage.includes('who can we thank') ||
                        lastVAMessage.includes('thank for') ||
                        lastVAMessage.includes('which friend')
                    );
                    
                    // Only trigger general availability if NOT asking about specific times or choices
                    const askingForAvailability = (lastVAMessage.includes('availability') || lastVAMessage.includes('when') || lastVAMessage.includes('what day')) && !askingMorningOrAfternoon && !askingEarlyOrLate && !timeMatches;

                    return `You are Sarah Johnson, a friendly patient on a phone call with a chiropractic office.

YOUR PERSONAL INFO (use these EXACT values when asked):
- Your name: Sarah Johnson
- Your phone number: 555-867-5309
- Your email: sarah.johnson@email.com
- Your problem: back pain for about 2 weeks
- Your availability: this week, mornings are best
- How you heard about them: a friend recommended you
- Friend's name (if asked): Tim

CONVERSATION SO FAR:
${convoText}

VA'S LAST MESSAGE: "${lastVAMessage}"

INSTRUCTIONS - ANSWER WHAT VA ASKED FOR:
${askingForName ? '- VA is asking for your NAME. Say ONLY: "Sarah Johnson"' : ''}
${askingForEmail && askingForPhone ? '- VA is asking for your EMAIL AND PHONE. Say: "My email is sarah.johnson@email.com and my phone number is 555-867-5309"' : ''}
${askingForEmail && !askingForPhone ? '- VA is asking for your EMAIL only. Say ONLY: "sarah.johnson@email.com"' : ''}
${askingForPhone && !askingForEmail ? '- VA is asking for your PHONE only. Say ONLY: "555-867-5309"' : ''}
${askingForReferral ? '- VA is asking HOW YOU HEARD about them. Say ONLY: "A friend recommended you"' : ''}
${askingWhoReferred ? '- VA is asking WHO your friend is. Say ONLY: "Tim"' : ''}
${askingForAvailability ? '- VA is asking about general AVAILABILITY. Say ONLY: "This week, mornings are best"' : ''}
${!askingForName && !askingForEmail && !askingForPhone && !askingForReferral && !askingWhoReferred && !askingForAvailability ? '- If they offer an appointment time: Say "Yes, that works for me" or "Perfect"\n- If they explain fees or what\'s included: Say "Okay, sounds good"\n- If they inform you about sending forms/emails: Say "Okay, thank you" or "Sounds good"\n- Otherwise, respond naturally and cooperatively to what they said' : ''}

CRITICAL: Only give your email/phone when VA is ASKING for it, not when they're just mentioning sending something to it.
DO NOT say your name unless they specifically ask for your name.
DO NOT say your email/phone when VA is just informing you about sending something.
DO NOT repeat information you already gave.
ONLY answer the specific question they just asked.

Give a short 1-2 sentence response. Be friendly and cooperative. Do not add labels or quotes.`;
                }

                // ==================== CHALLENGING MODE ====================
                if (diff === 'challenging') {
                    const selectedPattern = selectedQuestionsRef.current;
                    
                    if (isFirstResponse) {
                        // First question depends on pattern type
                        if (selectedPattern.type === 'insurance_triad') {
                            // Insurance Triad - Start with Q1
                            return `You are Mike Davis, calling a chiropractic office. You want to book but need some info about insurance first.

The receptionist just answered. Ask your first insurance question.

Say exactly: "Hi, I'd like to schedule an appointment, but first - ${selectedPattern.questions[0].question}"`;
                        } else {
                            // Other Questions - Pick first question
                            const firstQuestion = selectedPattern.questions[0];
                            return `You are Mike Davis, calling a chiropractic office. You want to book but need some info first.

The receptionist just answered. Ask your first question.

Say exactly: "Hi, I'd like to schedule an appointment, but first - ${firstQuestion.question}"`;
                        }
                    }

                    // Check what VA has mentioned and how they responded
                    const vaMessages = conversation.filter(m => m.speaker === 'VA');
                    const vaText = vaMessages.map(m => m.text.toLowerCase()).join(' ');
                    const lastVAMessage = vaMessages.length > 0 ? vaMessages[vaMessages.length - 1].text.toLowerCase() : '';
                    
                    // Track questions asked and answered
                    const patientMessages = conversation.filter(m => m.speaker === 'PATIENT');
                    const patientText = patientMessages.map(m => m.text.toLowerCase()).join(' ');
                    const questionsAsked = patientMessages.length;
                    
                    // Count BAD VA RESPONSES - CRITICAL CHECK FIRST
                    let badAnswerCount = 0;
                    vaMessages.forEach(msg => {
                        const msgText = msg.text.toLowerCase().trim();
                        
                        // Check for "I don't know" type responses - handles ANY apostrophe type
                        const hasIDont = msgText.includes("i don") || msgText.includes("i wouldn");
                        const hasDont = msgText.includes("don") && msgText.includes("know");
                        const hasWouldnt = msgText.includes("wouldn") && msgText.includes("know");
                        const hasNotSure = msgText.includes("not sure");
                        
                        if (hasIDont || hasDont || hasWouldnt || hasNotSure) {
                            badAnswerCount++;
                            console.log(`Bad answer detected: "I don't know" in "${msg.text}"`);
                        }
                        // Check for passing off to someone else - SEPARATE CHECK
                        if (msgText.includes("pass you to") || 
                            msgText.includes("transfer you") || 
                            msgText.includes("let me ask") ||
                            msgText.includes("check with") ||
                            msgText.includes("have to ask") ||
                            msgText.includes("need to ask")) {
                            badAnswerCount++;
                            console.log(`Bad answer detected: "passing off" in "${msg.text}"`);
                        }
                        // Check for non-answers (very short responses with just "um", "uh", "umm") - SEPARATE CHECK
                        if (msgText.length < 30 && 
                            (msgText === 'um' || 
                             msgText === 'uh' || 
                             msgText === 'umm' || 
                             msgText === 'uhh' ||
                             msgText.startsWith('um ') ||
                             msgText.startsWith('uh ') ||
                             msgText.startsWith('umm ') ||
                             msgText.startsWith('uhh '))) {
                            badAnswerCount++;
                            console.log(`Bad answer detected: "non-answer" in "${msg.text}"`);
                        }
                    });
                    
                    console.log(`TOTAL BAD ANSWER COUNT: ${badAnswerCount}/3`);
                    
                    // CRITICAL: If 3+ bad answers, REFUSE TO BOOK immediately - this must be checked FIRST
                    if (badAnswerCount >= 3) {
                        const refusalMessages = [
                            "Thank you for your time, but I need someone who can answer my questions. I'll call back another time. Goodbye.",
                            "I appreciate your time, but I need answers to my questions. I'll look for another office. Goodbye.",
                            "I need someone who knows the answers. I'll call elsewhere. Thank you anyway, goodbye.",
                            "This isn't working for me. I'll find another chiropractor who can help. Goodbye."
                        ];
                        
                        const randomRefusal = refusalMessages[Math.floor(Math.random() * refusalMessages.length)];
                        
                        return `The VA has given ${badAnswerCount} bad answers to your questions. You are frustrated and will NOT book.

CRITICAL: The VA could not answer your questions properly. DO NOT book the appointment.

Say EXACTLY: "${randomRefusal}"

Say ONLY that message, nothing else. This ends the call. DO NOT say you're ready to book.`;
                    }
                    
                    // Check which questions have been answered PROPERLY
                    // selectedPattern already declared at top of challenging mode section
                    let answeredQuestions = [];
                    
                    if (selectedPattern.type === 'insurance_triad') {
                        // Insurance Triad - check all 3 questions
                        answeredQuestions = selectedPattern.questions.filter(q => {
                            if (q.id === 'insurance_q2') {
                                // Q2 uses getQuestion, just check answer
                                return q.checkAnswer(vaText);
                            } else {
                                return q.checkAnswer(vaText);
                            }
                        });
                    } else {
                        // Other Questions
                        answeredQuestions = selectedPattern.questions.filter(q => q.checkAnswer(vaText));
                    }
                    
                    // Questions are only "answered" if VA actually gave good answers (not bad answers)
                    const questionsProperlyAnswered = answeredQuestions.length >= selectedPattern.totalQuestions && badAnswerCount < 3;
                    
                    // Check for RED FLAG responses
                    const vaIgnoredQuestion = lastVAMessage.length < 10 && !lastVAMessage.includes('yes') && !lastVAMessage.includes('no');
                    const vaPuntedToOthers = lastVAMessage.includes('let me ask') || lastVAMessage.includes('check with') || lastVAMessage.includes('someone else') || lastVAMessage.includes('not sure');
                    const vaVagueAboutInclusions = (patientMessages.some(p => p.text.toLowerCase().includes('include')) && (lastVAMessage.includes('figure it out') || lastVAMessage.includes('see when you come')));
                    
                    // Check if patient has already said they're ready to book OR asked about appointment availability
                    const patientSaidReadyToBook = patientMessages.some(p => {
                        const text = p.text.toLowerCase();
                        return text.includes("ready to book") || 
                               text.includes("let's book") || 
                               text.includes("book the appointment");
                    });
                    
                    // Check if patient asked about scheduling/appointments (indicates readiness)
                    const patientAskedAboutAppointments = patientMessages.some(p => {
                        const text = p.text.toLowerCase();
                        return text.includes("appointment this week") || 
                               text.includes("get an appointment") ||
                               text.includes("schedule this week") ||
                               text.includes("available this week");
                    });

                    // Patient is ready to book ONLY if questions were properly answered (no bad answers)
                    const readyToBook = questionsProperlyAnswered && (patientSaidReadyToBook || patientAskedAboutAppointments);

                    if (questionsProperlyAnswered && readyToBook) {
                        // SWITCH TO EASY MODE BEHAVIOR
                        
                        // Check if VA is offering CHOICES (A or B) - patient should pick one
                        const timeSlotPattern = /(\d{1,2})\s*(am|pm|a\.m|p\.m)/gi;
                        const timeMatches = lastVAMessage.match(timeSlotPattern);
                        
                        // Detect if VA is asking patient to choose between options
                        const askingMorningOrAfternoon = lastVAMessage.includes('morning') && lastVAMessage.includes('afternoon') && lastVAMessage.includes(' or ');
                        const askingEarlyOrLate = (lastVAMessage.includes('early') || lastVAMessage.includes('earlier')) && (lastVAMessage.includes('late') || lastVAMessage.includes('later')) && lastVAMessage.includes(' or ');
                        
                        if (timeMatches && timeMatches.length >= 2) {
                            // VA offered multiple time slots - pick one randomly
                            const randomTime = timeMatches[Math.floor(Math.random() * timeMatches.length)];
                            return `The VA just offered you multiple appointment times. Pick ONE specific time.

CONVERSATION SO FAR:
${convoText}

The VA's last message mentioned these times: ${timeMatches.join(', ')}

Pick ONE time randomly and respond with ONLY that choice.

Examples of good responses:
- "${randomTime} works great for me"
- "I'll take ${randomTime}"
- "${randomTime} is perfect"
- "Let's do ${randomTime}"

Pick one of these response styles randomly. Say nothing else.`;
                        }
                        
                        if (askingMorningOrAfternoon) {
                            // VA asking morning or afternoon - pick one
                            const choice = Math.random() < 0.5 ? 'morning' : 'afternoon';
                            return `The VA is asking if you prefer morning or afternoon.

Pick ONE randomly and respond naturally.

Examples:
- "${choice.charAt(0).toUpperCase() + choice.slice(1)} works better for me"
- "I'd prefer ${choice}"
- "${choice.charAt(0).toUpperCase() + choice.slice(1)} is best"
- "Let's do ${choice}"

Pick one response style randomly. Say nothing else.`;
                        }
                        
                        if (askingEarlyOrLate) {
                            // VA asking early or later in week - pick one
                            const choice = Math.random() < 0.5 ? 'earlier in the week' : 'later in the week';
                            return `The VA is asking if you prefer early or later in the week.

Pick ONE randomly and respond naturally.

Examples:
- "${choice.charAt(0).toUpperCase() + choice.slice(1)} works better for me"
- "I'd prefer ${choice}"
- "${choice.charAt(0).toUpperCase() + choice.slice(1)} is best"

Pick one response style randomly. Say nothing else.`;
                        }
                        
                        // Detect what information VA is REQUESTING (not just mentioning)
                        // Only respond with info if VA is ASKING for it, not just confirming/informing
                        const askingForEmail = (
                            (lastVAMessage.includes('email') && 
                            (lastVAMessage.includes('can i have') || 
                             lastVAMessage.includes('what is') || 
                             lastVAMessage.includes('what\'s') ||
                             lastVAMessage.includes('whats') ||
                             lastVAMessage.includes('may i have') ||
                             lastVAMessage.includes('i need') ||
                             lastVAMessage.includes('give me') ||
                             lastVAMessage.includes('send to') ||
                             lastVAMessage.includes('best email') ||
                             lastVAMessage.includes('your email'))) &&
                            !lastVAMessage.includes('sending') &&
                            !lastVAMessage.includes('send it to') &&
                            !lastVAMessage.includes('will send') &&
                            !lastVAMessage.includes('i\'ll send')
                        );
                        
                        const askingForPhone = (
                            (lastVAMessage.includes('phone') || lastVAMessage.includes('number')) && 
                            (lastVAMessage.includes('can i have') || 
                             lastVAMessage.includes('what is') || 
                             lastVAMessage.includes('what\'s') ||
                             lastVAMessage.includes('whats') ||
                             lastVAMessage.includes('may i have') ||
                             lastVAMessage.includes('i need') ||
                             lastVAMessage.includes('give me') ||
                             lastVAMessage.includes('best number') ||
                             lastVAMessage.includes('your phone') ||
                             lastVAMessage.includes('your number'))
                        );
                        
                        const askingForName = (
                            lastVAMessage.includes('name') && 
                            !askingForEmail && 
                            !askingForPhone &&
                            (lastVAMessage.includes('can i have') || 
                             lastVAMessage.includes('what is') || 
                             lastVAMessage.includes('what\'s') ||
                             lastVAMessage.includes('whats') ||
                             lastVAMessage.includes('may i have') ||
                             lastVAMessage.includes('i need') ||
                             lastVAMessage.includes('give me') ||
                             lastVAMessage.includes('full name') ||
                             lastVAMessage.includes('your name'))
                        );
                        
                        const askingForReferral = lastVAMessage.includes('hear about') || lastVAMessage.includes('find us') || lastVAMessage.includes('how did you');
                        
                        // Check if VA is asking for referral follow-up (who referred you)
                        const patientSaidGoogle = patientMessages.some(m => m.text.toLowerCase().includes('google'));
                        const askingWhoReferred = patientSaidGoogle && (
                            lastVAMessage.includes('who') || 
                            lastVAMessage.includes('who referred') ||
                            lastVAMessage.includes('name of') || 
                            lastVAMessage.includes('which friend') || 
                            lastVAMessage.includes('friend\'s name') ||
                            lastVAMessage.includes('who can we thank') ||
                            lastVAMessage.includes('thank for')
                        );
                        
                        // Only trigger general availability if NOT asking about specific times or choices
                        const askingForAvailability = (lastVAMessage.includes('availability') || lastVAMessage.includes('when') || lastVAMessage.includes('what day')) && !askingMorningOrAfternoon && !askingEarlyOrLate && !timeMatches;
                        
                        return `You are Mike Davis, a patient on a phone call with a chiropractic office. You've asked your questions and you're ready to book.

YOUR PERSONAL INFO (use these EXACT values when asked):
- Your name: Mike Davis
- Your phone number: 555-234-5678
- Your email: mike.davis@email.com
- Your availability: flexible, any day works
- How you heard about them: a friend recommended you
- Friend's name (if asked): Tim

CONVERSATION SO FAR:
${convoText}

VA'S LAST MESSAGE: "${lastVAMessage}"

CRITICAL INSTRUCTIONS - ANSWER WHAT VA ASKED FOR:
${askingForName ? '- VA is asking for your NAME. Say ONLY: "Mike Davis"' : ''}
${askingForEmail && askingForPhone ? '- VA is asking for your EMAIL AND PHONE. Say: "My email is mike.davis@email.com and my phone number is 555-234-5678"' : ''}
${askingForEmail && !askingForPhone ? '- VA is asking for your EMAIL only. Say ONLY: "mike.davis@email.com"' : ''}
${askingForPhone && !askingForEmail ? '- VA is asking for your PHONE only. Say ONLY: "555-234-5678"' : ''}
${askingForReferral ? '- VA is asking HOW YOU HEARD about them. Say ONLY: "A friend recommended you"' : ''}
${askingWhoReferred ? '- VA is asking WHO your friend is. Say ONLY: "Tim"' : ''}
${askingForAvailability ? '- VA is asking about general AVAILABILITY. Say ONLY: "Flexible, any day works"' : ''}
${!askingForName && !askingForEmail && !askingForPhone && !askingForReferral && !askingWhoReferred && !askingForAvailability ? '- If they offer an appointment time: Say "Yes, that works for me" or "Perfect, I\'ll be there"\n- If they confirm details or inform about sending forms: Say "Perfect, thank you!" or "Sounds good"\n- Otherwise, respond naturally to what they said' : ''}

CRITICAL: Only give your email/phone when VA is ASKING for it, not when they're just mentioning sending something to it.
DO NOT say your email/phone when VA is just informing you about sending something.
DO NOT repeat information you already gave.
DO NOT say your name unless they specifically ask for your name.
ONLY answer the specific question they just asked.

Give a short 1-2 sentence response. Be friendly and cooperative.`;
                    }

                    // Build list of questions to ask
                    let questionsToAsk = '';
                    if (selectedPattern.type === 'insurance_triad') {
                        // Insurance Triad - Show all 3 questions with dynamic Q2
                        const q2Text = selectedPattern.questions[1].getQuestion(selectedPattern.insuranceName);
                        questionsToAsk = `1. ${selectedPattern.questions[0].question}
2. ${q2Text}
3. ${selectedPattern.questions[2].question}`;
                    } else {
                        // Other Questions
                        questionsToAsk = selectedPattern.questions.map((q, idx) => 
                            `${idx + 1}. ${q.question}`
                        ).join('\n');
                    }

                    // Build status of answered questions
                    const questionStatus = selectedPattern.questions.map((q, idx) => 
                        answeredQuestions.includes(q) ? `âœ“ Question ${idx + 1} answered` : ''
                    ).filter(s => s).join('\n');
                    
                    // Check if VA is asking for referral follow-up
                    const patientSaidGoogle = patientMessages.some(m => m.text.toLowerCase().includes('google'));
                    const askingWhoReferred = patientSaidGoogle && (
                        lastVAMessage.includes('who') || 
                        lastVAMessage.includes('who referred') ||
                        lastVAMessage.includes('name of') || 
                        lastVAMessage.includes('which friend') ||
                        lastVAMessage.includes('friend\'s name') ||
                        lastVAMessage.includes('who can we thank') ||
                        lastVAMessage.includes('thank for')
                    );

                    return `You are Mike Davis, a patient calling a chiropractic office. You want to book but have ${selectedPattern.type === 'insurance_triad' ? 'insurance questions' : 'a few questions'} first.

YOUR PERSONAL INFO (use these EXACT values when asked):
- Your name: Mike Davis
- Your phone number: 555-234-5678
- Your email: mike.davis@email.com
- Your problem: neck pain and stiffness
- Your availability: flexible, any day works
- How you heard about them: found you on Google
- Friend who referred you (if asked): Tim
${selectedPattern.type === 'insurance_triad' ? `- Your insurance: ${selectedPattern.insuranceName}` : ''}

CONVERSATION SO FAR:
${convoText}

YOUR QUESTIONS TO ASK (in order):
${questionsToAsk}

STATUS:
- Questions you've asked so far: ${questionsAsked}/${selectedPattern.totalQuestions}
- Bad VA responses so far: ${badAnswerCount}/3 ${badAnswerCount >= 3 ? 'âŒ TOO MANY BAD ANSWERS' : ''}
- Questions properly answered: ${answeredQuestions.length}/${selectedPattern.totalQuestions}
${questionStatus}

${(() => {
    if (questionsProperlyAnswered) {
        return 'You\'ve asked all your questions and VA answered them well. Say: "Great, thank you for answering my questions. I\'m ready to book the appointment." Then STOP asking questions and wait for VA to guide you through booking.';
    }
    
    if (questionsAsked < selectedPattern.totalQuestions) {
        const nextQuestionIndex = questionsAsked;
        let nextQuestion = '';
        
        if (selectedPattern.type === 'insurance_triad') {
            if (nextQuestionIndex === 1) {
                // Q2 uses getQuestion
                nextQuestion = selectedPattern.questions[1].getQuestion(selectedPattern.insuranceName);
            } else {
                // Q1 and Q3 use .question
                nextQuestion = selectedPattern.questions[nextQuestionIndex].question;
            }
        } else {
            // Other questions just use .question
            nextQuestion = selectedPattern.questions[nextQuestionIndex].question;
        }
        
        const warning = badAnswerCount >= 2 ? `VA has given ${badAnswerCount} bad answers. If VA gives one more bad answer, you will refuse to book. ` : '';
        return `${warning}Ask Question ${questionsAsked + 1}: "${nextQuestion}"`;
    }
    
    return '';
})()}

${askingWhoReferred ? 'VA is asking WHO referred you. Say ONLY: "Tim"' : ''}

ACCEPTABLE VA ANSWERS:
${selectedPattern.type === 'insurance_triad' ? `- Q1 (Do you take insurance?): "We have programs that work with all types of insurance" or "Yes, we accept insurance" = GOOD
- Q2 (Is my insurance covered?): "We have patients with that insurance" or "We work with that insurance" = GOOD  
- Q3 (What does insurance cover?): "Bring your card and we'll verify" or "We'll check coverage" = GOOD` : `- Cost: Any range ($49-59), exact number ($59), or "varies/we'll discuss" = ALL GOOD
- Duration: "30-45 minutes" or similar = GOOD
- What to bring: "Insurance card, ID, previous records" = GOOD
- What's included: "Consultation, exam, adjustment" or similar = GOOD`}

DO NOT give all your information at once unless VA specifically asks for it.
DO NOT repeat information you already gave.
${askingWhoReferred ? '' : 'If VA asks who referred you, say "Tim".'}

Give a short 1-2 sentence response. Be polite and friendly.`;
                }

                // Fallback
                return `You are a patient calling a chiropractic office. The conversation so far: ${convoText}. Respond naturally in one sentence.`;
            };

            // Call OpenAI API
            const getPatientResponse = async () => {
                const prompt = buildPrompt();
                const key = apiKeyRef.current;
                
                console.log('=== API CALL ===');
                console.log('Prompt:', prompt);
                
                try {
                    const response = await fetch('https://api.openai.com/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${key}`
                        },
                        body: JSON.stringify({
                            model: 'gpt-4o-mini',
                            messages: [{ role: 'user', content: prompt }],
                            max_tokens: 150,
                            temperature: 0.7
                        })
                    });
                    
                    const data = await response.json();
                    
                    if (data.error) {
                        console.error('API Error:', data.error);
                        return "Sorry, could you repeat that?";
                    }
                    
                    let reply = data.choices[0].message.content.trim();
                    reply = reply.replace(/^(PATIENT:|Patient:|Me:|Caller:)\s*/i, '');
                    reply = reply.replace(/^["']|["']$/g, '');
                    
                    console.log('Patient reply:', reply);
                    return reply;
                } catch (error) {
                    console.error('Fetch error:', error);
                    return "I'm sorry, could you say that again?";
                }
            };

            // Evaluation
            const evaluateCall = async () => {
                const conversation = conversationRef.current;
                const convoText = conversation.map(m => `${m.speaker}: ${m.text}`).join('\n');
                const key = apiKeyRef.current;
                const diff = difficultyRef.current;
                const office = officeNameRef.current;
                const doctor = doctorNameRef.current;
                const cost = firstVisitCostRef.current;
                
                const evalPrompt = `Evaluate this VA's phone call performance at a chiropractic office.

CORRECT OFFICE INFO (what VA should have said):
- OFFICE NAME: ${office}
- DOCTOR NAME: Dr. ${doctor}
- FIRST VISIT COST: $${cost}

DIFFICULTY MODE: ${diff.toUpperCase()}

FULL CALL TRANSCRIPT:
${convoText}

EVALUATION CRITERIA - Score each 0-10:

1. GREETING & INTRODUCTION (0-10):
   IMPORTANT: Speech recognition often mishears office names. Be VERY LENIENT about office name pronunciation.
   
   Give 10/10 if VA did ALL of these:
   - Introduced with their own name (e.g., "This is Sarah" or "My name is Sarah")
   - ATTEMPTED to say the office name - even if speech recognition transcribed it incorrectly (e.g., "Brighton Spine" might show as "bread and spine")
   - Used friendly, professional tone
   - Said "How can I help you?" or similar offer to help
   
   CRITICAL: If you see ANY office-related words in the transcript near the greeting (even if misspelled/misheard), assume VA said the office name correctly. Give them full credit.
   
   Examples of speech recognition errors to forgive:
   - "Brighton Spine" â†’ "bread and spine", "brighton span", "right and spine"
   - "Smith Chiropractic" â†’ "smith care practice", "smith chiro"  
   - Any similar sounding words = GIVE CREDIT
   
   Give 8/10 if: Did greeting but missing ONE element (like "how can I help")
   Give 6/10 if: Said their name but NO office name attempted at all
   Give 4/10 if: No personal name AND no office name
   Give 0-2/10 if: No greeting at all

2. REASON FOR CALL (0-10):
   - Did VA identify why patient called (pain complaint, appointment request)?
   - Did they acknowledge it appropriately?
   - Did they show empathy/understanding?

3. SCHEDULING & TIME (0-10):
   - Did VA offer specific appointment date/time?
   - Did they confirm the appointment clearly?
   - Did they ask about patient's time preferences (morning/afternoon, early/late week)?
   - Did they provide 2+ time options for patient to choose from?

4. PATIENT INFORMATION (0-10):
   - Did VA collect full name?
   - Did VA collect phone number?
   - Did VA collect email address?
   - Give 10/10 only if ALL THREE were collected

5. REFERRAL SOURCE (0-10):
   - Did VA ask how patient heard about the office?
   - Did they note/acknowledge the response?

6. FEE EXPLANATION (0-10):
   CRITICAL: The correct explanation is "consultation, examination, and 1 free adjustment"
   
   Give 10/10 if VA mentions ALL THREE:
   - Consultation (or "consult")
   - Examination (or "exam")  
   - Adjustment (or "adjustment")
   AND mentions the price ($${cost})
   
   Give 8/10 if VA mentions:
   - The price AND 2 out of 3 items (e.g., "consultation and exam" but forgot adjustment)
   
   Give 5/10 if VA is vague:
   - "We'll go over everything on your first visit"
   - "We'll discuss what's included"
   - No specific details given
   
   Give 3/10 if VA only gives:
   - The price without any explanation of what's included
   
   Give 0-2/10 if VA:
   - Gives wrong price or provides no information at all

7. PROFESSIONAL CLOSING (0-10):
   - Did VA summarize the appointment details (date, time, location)?
   - Did VA mention what to bring (insurance card, previous records)?
   - Did VA mention next steps (intake form, arrival time)?
   - Did they end warmly and professionally?
   - Did they say goodbye appropriately?

BONUS POINTS (0-30) - Award points for excellence in these areas:

Communication Excellence (10 points max):
- Natural conversational flow (not robotic) = 3 points
- No awkward pauses or dead air = 2 points
- Appropriate speaking pace (not too fast/slow) = 2 points
- Active listening (responding to what patient said) = 3 points

Professionalism (10 points max):
- Warm, friendly tone throughout = 3 points
- Patient never had to repeat themselves = 2 points
- No "ums", "uhs", or filler words = 2 points
- Sounded confident and knowledgeable = 3 points

Problem Solving (10 points max):
- Answered patient questions smoothly = 4 points
- Handled objections or concerns well = 3 points
- Made patient feel heard and valued = 3 points

CRITICAL SCORING INSTRUCTIONS:
1. Add all 7 checkpoint scores (max 70 points)
2. Add bonus points (max 30 points)  
3. totalScore = checkpoint total + bonus points (max 100)

Example: If checkpoints total 68 and bonus = 25, then totalScore MUST = 93

CRITICAL: Check if patient ACTUALLY BOOKED:
- If patient said "I'll call back", "I'll look elsewhere", "not booking", "call another time" = patientBooked FALSE
- If VA said "I don't know" 3+ times = patientBooked FALSE and VA gets 0 points for those questions
- Only mark patientBooked = true if patient actually agreed to appointment

Return ONLY valid JSON (no markdown, no code blocks):
{
    "scores": {
        "greeting": {"score": 0, "note": ""},
        "reason": {"score": 0, "note": ""},
        "scheduling": {"score": 0, "note": ""},
        "patientInfo": {"score": 0, "note": ""},
        "referral": {"score": 0, "note": ""},
        "feeExplanation": {"score": 0, "note": ""},
        "closing": {"score": 0, "note": ""}
    },
    "bonusBreakdown": {
        "communication": 0,
        "professionalism": 0,
        "problemSolving": 0
    },
    "bonus": 0,
    "totalScore": 0,
    "positives": [""],
    "improvements": [""],
    "criticalMisses": [""],
    "patientBooked": true,
    "summary": ""
}`;

                try {
                    const response = await fetch('https://api.openai.com/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${key}`
                        },
                        body: JSON.stringify({
                            model: 'gpt-4o-mini',
                            messages: [{ role: 'user', content: evalPrompt }],
                            max_tokens: 1000,
                            temperature: 0.3
                        })
                    });
                    
                    const data = await response.json();
                    let content = data.choices[0].message.content.trim();
                    content = content.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();
                    return JSON.parse(content);
                } catch (error) {
                    console.error('Eval error:', error);
                    return null;
                }
            };

            const playAudio = async (text) => {
                setCurrentStatus('speaking');
                shouldListenRef.current = false;
                
                // Check if patient is refusing to book (new logic)
                const refusalPhrases = [
                    "i'll call back another time",
                    "i'll look for another office",
                    "i'll call elsewhere",
                    "i'll find another chiropractor",
                    "not booking",
                    "call another time"
                ];
                
                const isRefusal = refusalPhrases.some(phrase => text.toLowerCase().includes(phrase));
                
                try {
                    const response = await fetch('https://api.openai.com/v1/audio/speech', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKeyRef.current}`
                        },
                        body: JSON.stringify({
                            model: 'tts-1',
                            input: text,
                            voice: 'nova'
                        })
                    });
                    
                    const audioBlob = await response.blob();
                    const audioUrl = URL.createObjectURL(audioBlob);
                    const audio = new Audio(audioUrl);
                    audioRef.current = audio;
                    
                    audio.onended = () => {
                        // Check if this was a refusal to book - end call immediately
                        if (isRefusal) {
                            console.log('Patient refused to book - ending call immediately');
                            callEndingRef.current = true;
                            setTimeout(() => endCall(), 1000);
                            return;
                        }
                        
                        // Check if this was a goodbye response
                        if (isGoodbyePhrase(text) || callEndingRef.current) {
                            // Patient said goodbye - end the call
                            console.log('Call ending detected - patient said goodbye');
                            callEndingRef.current = true;
                            setTimeout(() => endCall(), 1000);
                        } else {
                            setCurrentStatus('listening');
                            shouldListenRef.current = true;
                            startListening();
                        }
                    };
                    
                    await audio.play();
                } catch (error) {
                    console.error('Audio error:', error);
                    setCurrentStatus('listening');
                    shouldListenRef.current = true;
                    startListening();
                }
            };

            const startListening = () => {
                if (recognitionRef.current && shouldListenRef.current) {
                    try {
                        recognitionRef.current.start();
                    } catch (e) {}
                }
            };

            useEffect(() => {
                if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
                    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                    recognitionRef.current = new SpeechRecognition();
                    recognitionRef.current.continuous = true;
                    recognitionRef.current.interimResults = true;

                    recognitionRef.current.onresult = (event) => {
                        let interim = '';
                        let final = '';
                        
                        for (let i = event.resultIndex; i < event.results.length; i++) {
                            if (event.results[i].isFinal) {
                                final += event.results[i][0].transcript;
                            } else {
                                interim += event.results[i][0].transcript;
                            }
                        }

                        if (interim) setInterimText(interim);
                        
                        if (final && shouldListenRef.current && !isProcessingRef.current) {
                            if (silenceTimerRef.current) clearTimeout(silenceTimerRef.current);
                            
                            lastTranscriptRef.current = (lastTranscriptRef.current + ' ' + final).trim();
                            setInterimText(lastTranscriptRef.current);
                            
                            silenceTimerRef.current = setTimeout(() => {
                                if (lastTranscriptRef.current && shouldListenRef.current) {
                                    handleVAResponse(lastTranscriptRef.current);
                                    lastTranscriptRef.current = '';
                                    setInterimText('');
                                }
                            }, 1500);
                        }
                    };

                    recognitionRef.current.onend = () => {
                        if (shouldListenRef.current && !callEndingRef.current) {
                            setTimeout(() => {
                                try { recognitionRef.current.start(); } catch (e) {}
                            }, 100);
                        }
                    };
                }
            }, []);

            const startCall = async () => {
                if (!difficulty || !officeName || !doctorName || !firstVisitCost) return;
                
                // Select random questions for challenging mode
                if (difficulty === 'challenging') {
                    selectedQuestionsRef.current = selectRandomQuestions();
                    const pattern = selectedQuestionsRef.current;
                    console.log('=== CHALLENGING MODE PATTERN ===');
                    console.log('Type:', pattern.type);
                    if (pattern.type === 'insurance_triad') {
                        console.log('Insurance Company:', pattern.insuranceName);
                        console.log('Questions: Insurance Triad (3 questions)');
                    } else {
                        console.log('Questions:', pattern.questions.length, 'random questions');
                        pattern.questions.forEach((q, i) => console.log(`  ${i+1}. ${q.question}`));
                    }
                    console.log('================================');
                }
                
                // Reset
                conversationRef.current = [];
                setMessages([]);
                setGameState('playing');
                callEndingRef.current = false;
                
                // Record start time
                const startTime = new Date();
                setCallStartTime(startTime);
                
                // Update refs immediately
                difficultyRef.current = difficulty;
                apiKeyRef.current = apiKey;
                officeNameRef.current = officeName;
                doctorNameRef.current = doctorName;
                firstVisitCostRef.current = firstVisitCost;
                
                console.log('=== CALL STARTED ===');
                console.log('Difficulty set to:', difficulty);
                console.log('Difficulty ref:', difficultyRef.current);
                
                setMessages([{ type: 'system', text: 'ðŸ“ž Incoming call...' }]);
                setCurrentStatus('idle');
                
                // Play phone ring
                await playPhoneRing();
                
                setMessages([{ type: 'system', text: 'ðŸ“ž Call connected! Answer with your greeting...' }]);
                setCurrentStatus('listening');
                shouldListenRef.current = true;
                
                setTimeout(() => startListening(), 500);
            };

            const handleVAResponse = async (transcript) => {
                if (isProcessingRef.current || callEndingRef.current) return;
                isProcessingRef.current = true;
                shouldListenRef.current = false;
                
                if (recognitionRef.current) {
                    try { recognitionRef.current.stop(); } catch (e) {}
                }
                
                setCurrentStatus('thinking');
                
                conversationRef.current.push({ speaker: 'VA', text: transcript });
                setMessages(prev => [...prev, { type: 'staff', text: transcript }]);
                
                // Check if VA is saying goodbye
                if (isGoodbyePhrase(transcript)) {
                    console.log('Goodbye phrase detected from VA:', transcript);
                    callEndingRef.current = true;
                }
                
                try {
                    const patientReply = await getPatientResponse();
                    
                    conversationRef.current.push({ speaker: 'PATIENT', text: patientReply });
                    setMessages(prev => [...prev, { type: 'patient', text: patientReply }]);
                    
                    await playAudio(patientReply);
                } catch (error) {
                    console.error('Error:', error);
                    setCurrentStatus('listening');
                    shouldListenRef.current = true;
                    startListening();
                }
                
                isProcessingRef.current = false;
            };

            const endCall = async () => {
                shouldListenRef.current = false;
                callEndingRef.current = true;
                if (recognitionRef.current) try { recognitionRef.current.stop(); } catch (e) {}
                if (audioRef.current) audioRef.current.pause();
                
                // Record end time
                const endTime = new Date();
                setCallEndTime(endTime);
                
                setCurrentStatus('thinking');
                setMessages(prev => [...prev, { type: 'system', text: 'ðŸ“Š Evaluating...' }]);
                
                const evalResult = await evaluateCall();
                
                if (evalResult) {
                    setScoreData(evalResult);
                } else {
                    setScoreData({
                        scores: {
                            greeting: { score: 5, note: 'Evaluation unavailable' },
                            reason: { score: 5, note: '' },
                            scheduling: { score: 5, note: '' },
                            patientInfo: { score: 5, note: '' },
                            referral: { score: 5, note: '' },
                            feeExplanation: { score: 5, note: '' },
                            closing: { score: 5, note: '' }
                        },
                        bonus: 15,
                        totalScore: 50,
                        positives: ['Call completed'],
                        improvements: ['Try again'],
                        criticalMisses: [],
                        patientBooked: true,
                        summary: 'Evaluation unavailable'
                    });
                }
                
                setGameState('scoring');
            };

            const resetGame = () => {
                shouldListenRef.current = false;
                callEndingRef.current = false;
                if (recognitionRef.current) try { recognitionRef.current.stop(); } catch (e) {}
                if (audioRef.current) audioRef.current.pause();
                conversationRef.current = [];
                selectedQuestionsRef.current = [];
                setGameState('setup');
                setDifficulty('');
                setMessages([]);
                setScoreData(null);
                setCurrentStatus('idle');
                setCallStartTime(null);
                setCallEndTime(null);
            };

            const canStart = officeName && doctorName && firstVisitCost && difficulty;

            // PASSWORD SCREEN
            if (!isAuthenticated) {
                return (
                    <div className="container">
                        <div className="header">
                            <h1>ðŸ” Virtual Front Desk Academy</h1>
                            <p>Enter your access code to begin training</p>
                        </div>
                        <div className="content" style={{textAlign: 'center'}}>
                            <input 
                                type="password"
                                placeholder="Access Code"
                                value={passwordInput}
                                onChange={(e) => setPasswordInput(e.target.value)}
                                onKeyPress={(e) => e.key === 'Enter' && checkPassword()}
                                style={{padding: '15px', fontSize: '16px', width: '100%', maxWidth: '300px', marginBottom: '15px', borderRadius: '10px', border: '2px solid #667eea'}}
                            />
                            {passwordError && <p style={{color: 'red', marginBottom: '15px'}}>{passwordError}</p>}
                            <br/>
                            <button className="start-btn" style={{maxWidth: '300px'}} onClick={checkPassword}>Access Trainer</button>
                            <p style={{marginTop: '20px', fontSize: '12px', color: '#666'}}>Don't have an access code? Contact your administrator.</p>
                        </div>
                    </div>
                );
            }

            // API KEY PROMPT
            if (showApiPrompt) {
                return (
                    <div className="container">
                        <div className="header">
                            <h1>ðŸ”‘ OpenAI API Key</h1>
                            <p>Enter your API key to use voice features</p>
                        </div>
                        <div className="content">
                            <div className="form-group">
                                <label>API Key</label>
                                <input 
                                    type="password"
                                    placeholder="sk-..."
                                    value={apiKey}
                                    onChange={(e) => setApiKey(e.target.value)}
                                />
                            </div>
                            <button className="start-btn" onClick={saveApiKey} disabled={!apiKey}>Save & Continue</button>
                        </div>
                    </div>
                );
            }

            // SETUP SCREEN
            if (gameState === 'setup') {
                return (
                    <div className="container">
                        <div className="header">
                            <h1>ðŸŽ¯ Virtual Front Desk Academy Trainer</h1>
                            <p>Practice your phone skills with AI patients</p>
                        </div>
                        <div className="content">
                            {currentVAName && (
                                <div style={{marginBottom: '25px', padding: '15px', background: '#e8f5e9', borderRadius: '10px', textAlign: 'center'}}>
                                    <strong>ðŸ‘‹ Welcome, {currentVAName}!</strong>
                                </div>
                            )}
                            
                            <h3 style={{marginBottom: '20px'}}>Office Information:</h3>
                            <div className="form-row">
                                <div className="form-group">
                                    <label>Office Name *</label>
                                    <input 
                                        type="text"
                                        placeholder="Smith Chiropractic"
                                        value={officeName}
                                        onChange={(e) => setOfficeName(e.target.value)}
                                    />
                                </div>
                                <div className="form-group">
                                    <label>Doctor's Last Name *</label>
                                    <input 
                                        type="text"
                                        placeholder="Smith"
                                        value={doctorName}
                                        onChange={(e) => setDoctorName(e.target.value)}
                                    />
                                </div>
                            </div>
                            <div className="form-row">
                                <div className="form-group">
                                    <label>First Visit Cost ($) *</label>
                                    <input 
                                        type="number"
                                        placeholder="59"
                                        value={firstVisitCost}
                                        onChange={(e) => setFirstVisitCost(e.target.value)}
                                    />
                                </div>
                                <div className="form-group">
                                    <label>Your Name (VA)</label>
                                    <input 
                                        type="text"
                                        placeholder="Your name"
                                        value={vaName}
                                        readOnly={currentVAName ? true : false}
                                        onChange={(e) => setVaName(e.target.value)}
                                        style={{background: currentVAName ? '#f5f5f5' : 'white', cursor: currentVAName ? 'not-allowed' : 'text'}}
                                    />
                                </div>
                            </div>
                            
                            <h3 style={{marginBottom: '20px', marginTop: '30px'}}>Select Difficulty:</h3>
                            <div className="difficulty-grid">
                                <div className={`difficulty-btn ${difficulty === 'easy' ? 'selected' : ''}`} onClick={() => setDifficulty('easy')}>
                                    <div style={{fontSize: '24px'}}>ðŸ˜Š</div>
                                    <div><strong>Easy</strong></div>
                                    <div style={{fontSize: '12px'}}>Cooperative patient, no questions</div>
                                </div>
                                <div className={`difficulty-btn ${difficulty === 'challenging' ? 'selected' : ''}`} onClick={() => setDifficulty('challenging')}>
                                    <div style={{fontSize: '24px'}}>ðŸ¤”</div>
                                    <div><strong>Challenging</strong></div>
                                    <div style={{fontSize: '12px'}}>Asks 2-3 random questions, then books</div>
                                </div>
                            </div>
                            <button className="start-btn" onClick={startCall} disabled={!canStart}>
                                {canStart ? 'Start Call' : 'Fill in all fields'}
                            </button>
                        </div>
                    </div>
                );
            }

            // PLAYING SCREEN
            if (gameState === 'playing') {
                return (
                    <div className="container">
                        <div className="header">
                            <h1>ðŸ“ž Call In Progress</h1>
                            <p>{officeName} - {difficulty.charAt(0).toUpperCase() + difficulty.slice(1)} Mode</p>
                        </div>
                        <div className="content">
                            <div className={`status-box status-${currentStatus}`}>
                                {currentStatus === 'listening' && 'ðŸŽ¤ Listening to you...'}
                                {currentStatus === 'speaking' && 'ðŸ”Š Patient speaking...'}
                                {currentStatus === 'thinking' && 'ðŸ’­ Processing...'}
                                {currentStatus === 'idle' && 'â¸ï¸ Ready'}
                            </div>
                            
                            {interimText && (
                                <div style={{padding: '10px', background: '#f0f0f0', borderRadius: '8px', marginBottom: '15px', fontStyle: 'italic'}}>
                                    Hearing: "{interimText}"
                                </div>
                            )}
                            
                            <div className="chat-container">
                                {messages.map((msg, i) => (
                                    <div key={i} className={`message ${msg.type}`}>
                                        {msg.type === 'staff' && <strong>You: </strong>}
                                        {msg.type === 'patient' && <strong>Patient: </strong>}
                                        {msg.text}
                                    </div>
                                ))}
                            </div>
                            
                            <button className="end-call-btn" onClick={endCall}>
                                â¹ï¸ End Call & Get Score
                            </button>
                        </div>
                    </div>
                );
            }

            // SCORING SCREEN
            if (gameState === 'scoring') {
                const checkpointTotal = Object.values(scoreData.scores).reduce((sum, c) => sum + c.score, 0);
                const passed = scoreData.totalScore >= 70;
                
                // Format timestamps
                const formatDate = (date) => {
                    if (!date) return 'N/A';
                    return date.toLocaleString('en-US', {
                        weekday: 'short',
                        year: 'numeric',
                        month: 'short',
                        day: 'numeric',
                        hour: '2-digit',
                        minute: '2-digit',
                        second: '2-digit'
                    });
                };
                
                const calculateDuration = () => {
                    if (!callStartTime || !callEndTime) return 'N/A';
                    const durationMs = callEndTime - callStartTime;
                    const minutes = Math.floor(durationMs / 60000);
                    const seconds = Math.floor((durationMs % 60000) / 1000);
                    return `${minutes}m ${seconds}s`;
                };

                return (
                    <div className="container">
                        <div className="header">
                            <h1>ðŸ“Š Your Score</h1>
                            <p>{passed ? 'âœ… PASSED' : 'âŒ NEEDS IMPROVEMENT'}</p>
                        </div>
                        <div className="content">
                            <div className="score-card">
                                {/* Timestamp Information */}
                                <div style={{marginBottom: '20px', padding: '15px', background: '#f0f0f0', borderRadius: '10px', fontSize: '13px'}}>
                                    <div style={{marginBottom: '8px'}}><strong>Office:</strong> {officeName}</div>
                                    <div style={{marginBottom: '8px'}}><strong>Doctor:</strong> Dr. {doctorName}</div>
                                    {vaName && <div style={{marginBottom: '8px'}}><strong>VA Name:</strong> {vaName}</div>}
                                    <div style={{marginBottom: '8px'}}><strong>Difficulty:</strong> {difficulty.charAt(0).toUpperCase() + difficulty.slice(1)}</div>
                                    <div style={{marginBottom: '8px'}}><strong>Call Duration:</strong> {calculateDuration()}</div>
                                    <div style={{marginBottom: '8px'}}><strong>Completed:</strong> {formatDate(callEndTime)}</div>
                                </div>
                                
                                <div className="overall-score" style={{color: passed ? '#4caf50' : '#f44336'}}>
                                    {scoreData.totalScore}/100
                                </div>
                                
                                <div style={{textAlign: 'center', marginBottom: '20px', padding: '15px', background: scoreData.patientBooked ? '#e8f5e9' : '#ffebee', borderRadius: '10px'}}>
                                    <strong>{scoreData.patientBooked ? 'âœ… Patient Booked!' : 'âŒ Patient Did Not Book'}</strong>
                                </div>
                                
                                {scoreData.summary && (
                                    <div style={{marginBottom: '20px', padding: '15px', background: '#f5f5f5', borderRadius: '10px'}}>
                                        <strong>Summary:</strong> {scoreData.summary}
                                    </div>
                                )}
                                
                                <h3 style={{marginBottom: '15px'}}>7 Checkpoints ({checkpointTotal}/70):</h3>
                                
                                {Object.entries(scoreData.scores).map(([key, data]) => {
                                    const labels = {
                                        greeting: 'Greeting & Introduction',
                                        reason: 'Identified Reason for Call',
                                        scheduling: 'Scheduling & Time',
                                        patientInfo: 'Collected Patient Info',
                                        referral: 'Asked Referral Source',
                                        feeExplanation: 'Explained Fee & Inclusions',
                                        closing: 'Professional Closing'
                                    };
                                    
                                    return (
                                        <div key={key} className="score-item" style={{background: data.score >= 7 ? '#e8f5e9' : data.score >= 4 ? '#fff3e0' : '#ffebee'}}>
                                            <div style={{display: 'flex', justifyContent: 'space-between'}}>
                                                <span>{data.score >= 7 ? 'âœ…' : data.score >= 4 ? 'âš ï¸' : 'âŒ'} {labels[key]}</span>
                                                <strong>{data.score}/10</strong>
                                            </div>
                                            {data.note && <p style={{fontSize: '13px', color: '#666', marginTop: '5px'}}>{data.note}</p>}
                                        </div>
                                    );
                                })}
                                
                                {/* Bonus Points Breakdown */}
                                <div style={{marginTop: '15px', padding: '15px', background: '#f5f5f5', borderRadius: '10px'}}>
                                    <strong>Bonus Points: {scoreData.bonus}/30</strong>
                                    
                                    {scoreData.bonusBreakdown && (
                                        <div style={{marginTop: '10px', fontSize: '13px'}}>
                                            <div style={{marginBottom: '5px'}}>
                                                â€¢ Communication Excellence: {scoreData.bonusBreakdown.communication || 0}/10
                                            </div>
                                            <div style={{marginBottom: '5px'}}>
                                                â€¢ Professionalism: {scoreData.bonusBreakdown.professionalism || 0}/10
                                            </div>
                                            <div style={{marginBottom: '5px'}}>
                                                â€¢ Problem Solving: {scoreData.bonusBreakdown.problemSolving || 0}/10
                                            </div>
                                        </div>
                                    )}
                                </div>
                                
                                {scoreData.positives?.filter(p => p).length > 0 && (
                                    <div className="feedback-section">
                                        <h4 className="positive">âœ… What You Did Well:</h4>
                                        <ul>{scoreData.positives.filter(p => p).map((item, i) => <li key={i}>{item}</li>)}</ul>
                                    </div>
                                )}
                                
                                {scoreData.improvements?.filter(p => p).length > 0 && (
                                    <div className="feedback-section">
                                        <h4 className="negative">ðŸ“ˆ Areas to Improve:</h4>
                                        <ul>{scoreData.improvements.filter(p => p).map((item, i) => <li key={i}>{item}</li>)}</ul>
                                    </div>
                                )}
                                
                                {scoreData.criticalMisses?.filter(p => p).length > 0 && (
                                    <div className="feedback-section" style={{background: '#ffebee'}}>
                                        <h4 className="critical">ðŸš¨ Critical Misses:</h4>
                                        <ul>{scoreData.criticalMisses.filter(p => p).map((item, i) => <li key={i}>{item}</li>)}</ul>
                                    </div>
                                )}
                            </div>
                            
                            <button className="start-btn" onClick={resetGame} style={{marginTop: '20px'}}>Try Another Call</button>
                        </div>
                    </div>
                );
            }

            return null;
        }

        ReactDOM.render(<ChiroVoiceTrainer />, document.getElementById('root'));
    </script>
</body>
</html>
