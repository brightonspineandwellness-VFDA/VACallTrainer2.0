<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chiro Voice Training 2.0</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        .container {
            max-width: 900px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        .header h1 { font-size: 28px; margin-bottom: 10px; }
        .header p { opacity: 0.9; font-size: 16px; }
        .content { padding: 40px; }
        .form-group {
            margin-bottom: 20px;
        }
        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #333;
        }
        .form-group input {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            font-size: 16px;
            transition: border-color 0.3s;
        }
        .form-group input:focus {
            outline: none;
            border-color: #667eea;
        }
        .form-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }
        .difficulty-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin-bottom: 30px;
        }
        .difficulty-btn {
            padding: 20px;
            border: 3px solid #e0e0e0;
            border-radius: 15px;
            background: white;
            cursor: pointer;
            text-align: center;
            transition: all 0.3s;
        }
        .difficulty-btn:hover { border-color: #667eea; transform: translateY(-2px); }
        .difficulty-btn.selected { background: #667eea; color: white; border-color: #667eea; }
        .start-btn {
            width: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 50px;
            border-radius: 30px;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
        }
        .start-btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .chat-container {
            background: #f5f5f5;
            border-radius: 15px;
            padding: 20px;
            max-height: 350px;
            overflow-y: auto;
            margin-bottom: 20px;
        }
        .message {
            margin-bottom: 15px;
            padding: 12px 18px;
            border-radius: 15px;
            max-width: 80%;
        }
        .message.staff { background: #667eea; color: white; margin-left: auto; }
        .message.patient { background: white; border: 1px solid #ddd; }
        .message.system { background: #ffc107; text-align: center; max-width: 100%; }
        .end-call-btn {
            width: 100%;
            background: #dc3545;
            color: white;
            border: none;
            padding: 15px;
            border-radius: 10px;
            font-size: 16px;
            cursor: pointer;
        }
        .score-card { background: #f9f9f9; border-radius: 15px; padding: 25px; }
        .overall-score {
            font-size: 64px;
            font-weight: bold;
            text-align: center;
            margin-bottom: 30px;
        }
        .score-item {
            background: white;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 10px;
        }
        .status-box {
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            text-align: center;
            font-weight: bold;
        }
        .status-listening { background: #e8f5e9; color: #2e7d32; }
        .status-speaking { background: #e3f2fd; color: #1565c0; }
        .status-thinking { background: #fff3e0; color: #ef6c00; }
        .status-waiting { background: #f3e5f5; color: #7b1fa2; }
        .feedback-section {
            margin-top: 20px;
            padding: 15px;
            background: white;
            border-radius: 10px;
        }
        .feedback-section h4 {
            margin-bottom: 10px;
            color: #333;
        }
        .feedback-section ul {
            margin-left: 20px;
        }
        .feedback-section li {
            margin-bottom: 5px;
        }
        .positive { color: #2e7d32; }
        .negative { color: #c62828; }
        .critical { color: #d32f2f; font-weight: bold; }
        .debug-panel {
            margin-top: 20px;
            padding: 15px;
            background: #f0f0f0;
            border-radius: 10px;
            font-size: 12px;
        }
        .debug-panel pre {
            white-space: pre-wrap;
            word-wrap: break-word;
        }
    </style>
</head>
<body>
    <div id="root"></div>
    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        const APP_PASSWORD = "ChiroTrain2025";
        const STORED_KEY = localStorage.getItem('openai_api_key');

        function ChiroVoiceTrainer() {
            const [isAuthenticated, setIsAuthenticated] = useState(sessionStorage.getItem('auth') === 'true');
            const [passwordInput, setPasswordInput] = useState('');
            const [passwordError, setPasswordError] = useState('');
            const [apiKey, setApiKey] = useState(STORED_KEY || '');
            const [showApiPrompt, setShowApiPrompt] = useState(!STORED_KEY);
            const [gameState, setGameState] = useState('setup');
            
            // Form fields
            const [officeName, setOfficeName] = useState('');
            const [doctorName, setDoctorName] = useState('');
            const [firstVisitCost, setFirstVisitCost] = useState('');
            const [vaName, setVaName] = useState('');
            
            const [difficulty, setDifficulty] = useState('');
            const [messages, setMessages] = useState([]);
            const [currentStatus, setCurrentStatus] = useState('idle');
            const [scoreData, setScoreData] = useState(null);
            const [interimText, setInterimText] = useState('');
            const [turnCount, setTurnCount] = useState(0);
            const [showDebug, setShowDebug] = useState(false);

            // Use ref for conversation to avoid state sync issues
            const conversationRef = useRef([]);
            const recognitionRef = useRef(null);
            const shouldListenRef = useRef(false);
            const isProcessingRef = useRef(false);
            const silenceTimerRef = useRef(null);
            const lastTranscriptRef = useRef('');
            const audioRef = useRef(null);

            const checkPassword = () => {
                if (passwordInput === APP_PASSWORD) {
                    sessionStorage.setItem('auth', 'true');
                    setIsAuthenticated(true);
                } else {
                    setPasswordError('Wrong password');
                    setPasswordInput('');
                }
            };

            const saveApiKey = () => {
                localStorage.setItem('openai_api_key', apiKey);
                setShowApiPrompt(false);
            };

            // Patient personas - defined as constants
            const PATIENT_PERSONAS = {
                easy: {
                    name: 'Sarah Johnson',
                    phone: '555-867-5309',
                    email: 'sarah.johnson@email.com',
                    problem: 'back pain for about 2 weeks',
                    availability: 'this week, mornings are best',
                    referral: 'a friend recommended you',
                    personality: 'friendly and cooperative'
                },
                challenging: {
                    name: 'Mike Davis',
                    phone: '555-234-5678',
                    email: 'mike.davis@email.com',
                    problem: 'neck pain and stiffness',
                    availability: 'flexible, any day works',
                    referral: 'found you on Google',
                    personality: 'price-conscious, asks about cost and insurance',
                    insurance: 'Blue Cross Blue Shield'
                },
                difficult: {
                    name: 'Karen Miller',
                    phone: '555-345-6789',
                    email: 'karen.m@email.com',
                    problem: 'chronic lower back pain',
                    availability: 'afternoons only',
                    referral: 'found you on my insurance website',
                    personality: 'skeptical, been overcharged before, wants specifics',
                    insurance: 'Aetna'
                },
                creepy: {
                    name: 'John',
                    phone: '555-000-0000',
                    email: 'rather not say',
                    problem: 'some tension',
                    availability: 'anytime',
                    referral: 'just found you online',
                    personality: 'starts normal then becomes inappropriate'
                }
            };

            // Get patient persona based on difficulty
            const getPatientPersona = (diff) => {
                const d = diff || difficulty;
                console.log('Getting persona for difficulty:', d);
                return PATIENT_PERSONAS[d] || PATIENT_PERSONAS.easy;
            };

            // Simple, clear prompt for patient responses
            const buildSimplePrompt = () => {
                const persona = getPatientPersona(difficulty);
                const conversation = conversationRef.current;
                
                console.log('Building prompt with persona:', persona);
                console.log('Difficulty:', difficulty);
                console.log('Turn count:', turnCount);
                
                // Build conversation string
                let convoText = '';
                conversation.forEach((msg, i) => {
                    convoText += `${msg.speaker}: ${msg.text}\n`;
                });

                // Check if this is the first patient response
                const isFirstResponse = conversation.filter(m => m.speaker === 'PATIENT').length === 0;
                const patientTurnCount = conversation.filter(m => m.speaker === 'PATIENT').length;

                // ============ CREEPY MODE ============
                if (difficulty === 'creepy') {
                    if (isFirstResponse) {
                        return `You are a caller phoning a chiropractic office. Start completely normal.

The receptionist just answered. Say you want to book an appointment for some back tension.

Respond with ONE normal, friendly sentence like: "Hi, I'd like to schedule an appointment for some back tension."`;
                    }

                    return `You are a caller on the phone with a chiropractic office receptionist.

CONVERSATION SO FAR:
${convoText}

TURN NUMBER: ${patientTurnCount + 1}

BEHAVIOR INSTRUCTIONS:
- Turns 1-2: Be COMPLETELY NORMAL. Answer questions, provide info if asked.
- Turn 3+: START BEING INAPPROPRIATE. Choose from:
  * Ask personal questions: "So... are you single?" or "What do you look like?"
  * Make uncomfortable comments: "You have such a nice voice..." or "I bet you're really pretty"
  * Ask weird unrelated questions: "What are you wearing right now?" or "Do you work there alone?"

- If the VA sets boundaries, says this is inappropriate, or tries to end the call:
  * Say something like "Okay, sorry, I'll find another office. Goodbye." and END the conversation.

- NEVER be explicit, threatening, or use profanity.

Respond with ONE sentence. No labels, no quotes.`;
                }

                // ============ EASY MODE ============
                if (difficulty === 'easy') {
                    if (isFirstResponse) {
                        return `You are ${persona.name}, calling a chiropractic office to book an appointment.

The receptionist just answered the phone. Say you want to schedule an appointment for ${persona.problem}.

Respond with ONE short friendly sentence. Example: "Hi, I'd like to schedule an appointment. I've been having ${persona.problem}."`;
                    }

                    return `You are ${persona.name}, a friendly patient on a phone call with a chiropractic office.

YOUR INFO:
- Name: ${persona.name}
- Phone: ${persona.phone}
- Email: ${persona.email}
- Problem: ${persona.problem}
- Availability: ${persona.availability}
- How you found them: ${persona.referral}

CONVERSATION SO FAR:
${convoText}

PERSONALITY: Friendly, cooperative, easy-going. You just want to book and get help for your ${persona.problem}.

INSTRUCTIONS:
1. READ the VA's last message carefully.
2. ANSWER their question directly and helpfully.
3. If asked for name: "${persona.name}"
4. If asked for phone: "${persona.phone}"
5. If asked for email: "${persona.email}"
6. If asked about scheduling/availability: "${persona.availability}"
7. If asked how you heard about them: "${persona.referral}"
8. If they offer an appointment time, accept it cheerfully.
9. If they explain fees or what to bring, say "Okay, sounds good" or similar.

DO NOT ask questions about cost, insurance, or services - you trust them.
DO NOT repeat your opening line about scheduling.
Keep responses to 1-2 short sentences.`;
                }

                // ============ CHALLENGING MODE ============
                if (difficulty === 'challenging') {
                    if (isFirstResponse) {
                        return `You are ${persona.name}, calling a chiropractic office. You want to book but you're price-conscious.

The receptionist just answered. You want to schedule but FIRST you want to know the cost.

Say something like: "Hi, I'd like to schedule an appointment, but first - how much does the first visit cost?"`;
                    }

                    // Check if VA has addressed cost concerns
                    const vaMessages = conversation.filter(m => m.speaker === 'VA').map(m => m.text.toLowerCase()).join(' ');
                    const costMentioned = vaMessages.includes('$') || vaMessages.includes('dollar') || vaMessages.includes('cost') || vaMessages.includes('fee') || vaMessages.includes('price');
                    const insuranceMentioned = vaMessages.includes('insurance') || vaMessages.includes('blue cross') || vaMessages.includes('coverage');

                    // Questions the patient still wants to ask
                    let pendingQuestions = [];
                    if (!costMentioned) pendingQuestions.push("How much is the first visit?");
                    if (!insuranceMentioned && patientTurnCount < 3) pendingQuestions.push("Do you accept Blue Cross Blue Shield?");
                    if (costMentioned && !vaMessages.includes('include') && patientTurnCount < 4) pendingQuestions.push("What does that include?");

                    return `You are ${persona.name}, a price-conscious patient calling a chiropractic office.

YOUR INFO:
- Name: ${persona.name}
- Phone: ${persona.phone}
- Email: ${persona.email}
- Problem: ${persona.problem}
- Availability: ${persona.availability}
- How you found them: ${persona.referral}
- Insurance: Blue Cross Blue Shield

CONVERSATION SO FAR:
${convoText}

PERSONALITY: Friendly but PRICE-CONSCIOUS. You want to know costs before committing.

QUESTIONS YOU CARE ABOUT:
- "How much is the first visit?" 
- "Do you accept Blue Cross Blue Shield?"
- "What does that include?"
- "How long is the appointment?"
- You may also ask about services like decompression or laser therapy if relevant.

BEHAVIOR RULES:
1. If VA hasn't explained the cost yet, ask about it before giving your info.
2. If VA explains cost clearly and it sounds reasonable, proceed to book.
3. If VA is VAGUE about cost, keeps avoiding the question, or seems evasive:
   - Say something like: "I appreciate your time, but I need to know the exact costs upfront. I'll think about it and maybe call back. Goodbye."
   - This means you are NOT booking.
4. Once your questions are answered satisfactorily, cooperate and give your info when asked.

If asked for your info:
- Name: "${persona.name}"
- Phone: "${persona.phone}"
- Email: "${persona.email}"
- Availability: "${persona.availability}"
- Referral: "${persona.referral}"

Respond with 1-2 sentences. Be polite but firm about wanting cost info.`;
                }

                // ============ SKEPTICAL/DIFFICULT MODE ============
                if (difficulty === 'difficult') {
                    if (isFirstResponse) {
                        return `You are ${persona.name}, calling a chiropractic office. You're SKEPTICAL because you've been overcharged by healthcare providers before.

The receptionist just answered. You want to book but you have concerns.

Say something like: "Hi, I'm calling about scheduling an appointment, but I have some questions first. I've had bad experiences with chiropractors overcharging me in the past."`;
                    }

                    const vaMessages = conversation.filter(m => m.speaker === 'VA').map(m => m.text.toLowerCase()).join(' ');
                    
                    // Track what concerns have been addressed
                    const costExplained = vaMessages.includes('$') || vaMessages.includes('dollar') || vaMessages.includes('fee');
                    const noHiddenFees = vaMessages.includes('no hidden') || vaMessages.includes('that includes') || vaMessages.includes('covers');
                    const treatmentPlanAddressed = vaMessages.includes('up to you') || vaMessages.includes('your choice') || vaMessages.includes('no obligation') || vaMessages.includes('recommend');

                    return `You are ${persona.name}, a SKEPTICAL patient calling a chiropractic office.

YOUR INFO:
- Name: ${persona.name}
- Phone: ${persona.phone}
- Email: ${persona.email}
- Problem: ${persona.problem}
- Availability: ${persona.availability}
- How you found them: ${persona.referral}
- Insurance: Aetna

CONVERSATION SO FAR:
${convoText}

PERSONALITY: SKEPTICAL. You've been burned before by chiropractors who upsold you on unnecessary treatments. You need convincing.

YOUR OBJECTIONS (raise these throughout the conversation):
1. "That sounds expensive - are there any hidden fees I should know about?"
2. "How many visits will I actually need? I don't want to be locked into some long treatment plan."
3. "Do I really need X-rays? Is that necessary or just extra cost?"
4. "I've been to chiropractors before and felt like I was constantly being upsold."

BEHAVIOR RULES:
1. Don't give your personal info until you feel your concerns are addressed.
2. Push back on vague answers - ask for specifics.
3. If VA addresses your concerns clearly and professionally, gradually warm up and eventually book.
4. If VA is dismissive, vague, or pushy:
   - Say: "You know what, this doesn't feel right. I'm going to look elsewhere. Thank you for your time, goodbye."
   - This means you are NOT booking.
5. Pushback level: MODERATE (3/5) - be skeptical but not hostile.

If VA earns your trust and you decide to book:
- Name: "${persona.name}"
- Phone: "${persona.phone}"
- Email: "${persona.email}"
- Availability: "${persona.availability}"
- Referral: "${persona.referral}"

Respond with 1-2 sentences. Be polite but skeptical. Ask tough questions.`;
                }

                // Fallback (shouldn't reach here)
                return `You are a patient calling a chiropractic office. Respond naturally to the receptionist.

CONVERSATION: ${convoText}

Respond with one short sentence.`;
            };
            };

            // Call OpenAI with simple prompt
            const getPatientResponse = async () => {
                const prompt = buildSimplePrompt();
                
                console.log('=== API CALL ===');
                console.log('Turn:', turnCount);
                console.log('Conversation:', conversationRef.current);
                console.log('Prompt:', prompt);
                
                try {
                    const response = await fetch('https://api.openai.com/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`
                        },
                        body: JSON.stringify({
                            model: 'gpt-4o-mini',
                            messages: [
                                { role: 'user', content: prompt }
                            ],
                            max_tokens: 100,
                            temperature: 0.7
                        })
                    });
                    
                    const data = await response.json();
                    console.log('API Response:', data);
                    
                    if (data.error) {
                        console.error('API Error:', data.error);
                        return "Sorry, I didn't catch that. Could you repeat?";
                    }
                    
                    let reply = data.choices[0].message.content.trim();
                    // Clean up any labels the AI might add
                    reply = reply.replace(/^(PATIENT:|Patient:|Me:|Caller:)\s*/i, '');
                    reply = reply.replace(/^["']|["']$/g, '');
                    
                    return reply;
                } catch (error) {
                    console.error('Fetch error:', error);
                    return "I'm sorry, could you say that again?";
                }
            };

            // Evaluation prompt
            const evaluateCall = async () => {
                const conversation = conversationRef.current;
                let convoText = conversation.map(m => `${m.speaker}: ${m.text}`).join('\n');
                
                const evalPrompt = `You are evaluating a Virtual Assistant's phone call performance at a chiropractic office.

OFFICE INFO:
- Office: ${officeName}
- Doctor: Dr. ${doctorName}
- First Visit Cost: $${firstVisitCost}

CONVERSATION:
${convoText}

DIFFICULTY: ${difficulty.toUpperCase()}

Score each item 0-10:
1. GREETING: Did VA introduce themselves with name AND office name?
2. REASON: Did VA identify why patient is calling?
3. SCHEDULING: Did VA offer and confirm appointment time?
4. PATIENT INFO: Did VA get name, phone, and/or email?
5. REFERRAL: Did VA ask "how did you hear about us"?
6. FEE EXPLANATION: Did VA explain the first visit cost ($${firstVisitCost}) and what it includes?
7. CLOSING: Did VA confirm details and close professionally?

Also give up to 30 bonus points for overall flow, professionalism, and handling the ${difficulty} difficulty level.

Respond ONLY with valid JSON:
{
    "scores": {
        "greeting": {"score": 0, "note": ""},
        "reason": {"score": 0, "note": ""},
        "scheduling": {"score": 0, "note": ""},
        "patientInfo": {"score": 0, "note": ""},
        "referral": {"score": 0, "note": ""},
        "feeExplanation": {"score": 0, "note": ""},
        "closing": {"score": 0, "note": ""}
    },
    "bonus": 0,
    "totalScore": 0,
    "positives": ["", ""],
    "improvements": ["", ""],
    "criticalMisses": [""],
    "patientBooked": true,
    "summary": ""
}`;

                try {
                    const response = await fetch('https://api.openai.com/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`
                        },
                        body: JSON.stringify({
                            model: 'gpt-4o-mini',
                            messages: [{ role: 'user', content: evalPrompt }],
                            max_tokens: 800,
                            temperature: 0.3
                        })
                    });
                    
                    const data = await response.json();
                    let content = data.choices[0].message.content.trim();
                    content = content.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();
                    
                    return JSON.parse(content);
                } catch (error) {
                    console.error('Eval error:', error);
                    return null;
                }
            };

            const playAudio = async (text) => {
                setCurrentStatus('speaking');
                shouldListenRef.current = false;
                
                try {
                    const response = await fetch('https://api.openai.com/v1/audio/speech', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`
                        },
                        body: JSON.stringify({
                            model: 'tts-1',
                            input: text,
                            voice: 'nova'
                        })
                    });
                    
                    const audioBlob = await response.blob();
                    const audioUrl = URL.createObjectURL(audioBlob);
                    const audio = new Audio(audioUrl);
                    audioRef.current = audio;
                    
                    audio.onended = () => {
                        setCurrentStatus('listening');
                        shouldListenRef.current = true;
                        startListening();
                    };
                    
                    await audio.play();
                } catch (error) {
                    console.error('Audio error:', error);
                    setCurrentStatus('listening');
                    shouldListenRef.current = true;
                    startListening();
                }
            };

            const startListening = () => {
                if (recognitionRef.current && shouldListenRef.current) {
                    try {
                        recognitionRef.current.start();
                    } catch (e) {
                        console.log('Recognition already started');
                    }
                }
            };

            useEffect(() => {
                if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
                    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                    recognitionRef.current = new SpeechRecognition();
                    recognitionRef.current.continuous = true;
                    recognitionRef.current.interimResults = true;

                    recognitionRef.current.onresult = (event) => {
                        let interim = '';
                        let final = '';
                        
                        for (let i = event.resultIndex; i < event.results.length; i++) {
                            if (event.results[i].isFinal) {
                                final += event.results[i][0].transcript;
                            } else {
                                interim += event.results[i][0].transcript;
                            }
                        }

                        if (interim) setInterimText(interim);
                        
                        if (final && shouldListenRef.current && !isProcessingRef.current) {
                            if (silenceTimerRef.current) clearTimeout(silenceTimerRef.current);
                            
                            lastTranscriptRef.current = (lastTranscriptRef.current + ' ' + final).trim();
                            setInterimText(lastTranscriptRef.current);
                            
                            silenceTimerRef.current = setTimeout(() => {
                                if (lastTranscriptRef.current && shouldListenRef.current) {
                                    handleVAResponse(lastTranscriptRef.current);
                                    lastTranscriptRef.current = '';
                                    setInterimText('');
                                }
                            }, 1500);
                        }
                    };

                    recognitionRef.current.onend = () => {
                        if (shouldListenRef.current) {
                            setTimeout(() => {
                                try { recognitionRef.current.start(); } catch (e) {}
                            }, 100);
                        }
                    };

                    recognitionRef.current.onerror = (event) => {
                        console.log('Recognition error:', event.error);
                    };
                }
            }, []);

            const startCall = async () => {
                if (!difficulty || !officeName || !doctorName || !firstVisitCost) return;
                
                // Reset everything
                conversationRef.current = [];
                setMessages([]);
                setTurnCount(0);
                setGameState('playing');
                
                // Show instruction
                setMessages([{ 
                    type: 'system', 
                    text: 'üìû Incoming call! Answer with your greeting...' 
                }]);
                
                // Start listening for VA's greeting
                setCurrentStatus('listening');
                shouldListenRef.current = true;
                
                setTimeout(() => {
                    startListening();
                }, 500);
            };

            const handleVAResponse = async (transcript) => {
                if (isProcessingRef.current) return;
                isProcessingRef.current = true;
                shouldListenRef.current = false;
                
                if (recognitionRef.current) {
                    try { recognitionRef.current.stop(); } catch (e) {}
                }
                
                setCurrentStatus('thinking');
                
                // Add VA message to conversation
                conversationRef.current.push({ speaker: 'VA', text: transcript });
                setMessages(prev => [...prev, { type: 'staff', text: transcript }]);
                
                console.log('VA said:', transcript);
                console.log('Current conversation:', conversationRef.current);
                
                try {
                    // Get patient response
                    const patientReply = await getPatientResponse();
                    
                    // Add patient message to conversation
                    conversationRef.current.push({ speaker: 'PATIENT', text: patientReply });
                    setMessages(prev => [...prev, { type: 'patient', text: patientReply }]);
                    setTurnCount(prev => prev + 1);
                    
                    console.log('Patient replied:', patientReply);
                    
                    // Play audio
                    await playAudio(patientReply);
                } catch (error) {
                    console.error('Error in handleVAResponse:', error);
                    setCurrentStatus('listening');
                    shouldListenRef.current = true;
                    startListening();
                }
                
                isProcessingRef.current = false;
            };

            const endCall = async () => {
                shouldListenRef.current = false;
                if (recognitionRef.current) try { recognitionRef.current.stop(); } catch (e) {}
                if (audioRef.current) audioRef.current.pause();
                
                setCurrentStatus('thinking');
                setMessages(prev => [...prev, { type: 'system', text: 'üìä Evaluating your performance...' }]);
                
                // Handle creepy mode
                if (difficulty === 'creepy') {
                    const conversation = conversationRef.current;
                    const vaHandledIt = conversation.some(msg => 
                        msg.speaker === 'VA' && 
                        (msg.text.toLowerCase().includes('inappropriate') ||
                         msg.text.toLowerCase().includes('end this call') ||
                         msg.text.toLowerCase().includes('not appropriate') ||
                         msg.text.toLowerCase().includes('goodbye') ||
                         msg.text.toLowerCase().includes('hang up'))
                    );
                    
                    setScoreData({
                        isCreepy: true,
                        passed: vaHandledIt,
                        result: vaHandledIt ? 'PASS ‚úÖ' : 'NEEDS WORK',
                        feedback: vaHandledIt 
                            ? 'Good job recognizing and handling the inappropriate caller!'
                            : 'Remember to set boundaries and end calls when callers become inappropriate.'
                    });
                    setGameState('scoring');
                    return;
                }
                
                // Regular evaluation
                const evalResult = await evaluateCall();
                
                if (evalResult) {
                    setScoreData(evalResult);
                } else {
                    // Fallback
                    setScoreData({
                        scores: {
                            greeting: { score: 5, note: 'Could not fully evaluate' },
                            reason: { score: 5, note: 'Could not fully evaluate' },
                            scheduling: { score: 5, note: 'Could not fully evaluate' },
                            patientInfo: { score: 5, note: 'Could not fully evaluate' },
                            referral: { score: 5, note: 'Could not fully evaluate' },
                            feeExplanation: { score: 5, note: 'Could not fully evaluate' },
                            closing: { score: 5, note: 'Could not fully evaluate' }
                        },
                        bonus: 15,
                        totalScore: 50,
                        positives: ['Call completed'],
                        improvements: ['Try again for detailed feedback'],
                        criticalMisses: [],
                        patientBooked: true,
                        summary: 'Evaluation incomplete - try again'
                    });
                }
                
                setGameState('scoring');
            };

            const resetGame = () => {
                shouldListenRef.current = false;
                if (recognitionRef.current) try { recognitionRef.current.stop(); } catch (e) {}
                if (audioRef.current) audioRef.current.pause();
                conversationRef.current = [];
                setGameState('setup');
                setDifficulty('');
                setMessages([]);
                setScoreData(null);
                setCurrentStatus('idle');
                setTurnCount(0);
            };

            // PASSWORD SCREEN
            if (!isAuthenticated) {
                return (
                    <div className="container">
                        <div className="header">
                            <h1>üîê Chiro Voice Training</h1>
                            <p>Enter password to access</p>
                        </div>
                        <div className="content" style={{textAlign: 'center'}}>
                            <input 
                                type="password"
                                placeholder="Password"
                                value={passwordInput}
                                onChange={(e) => setPasswordInput(e.target.value)}
                                onKeyPress={(e) => e.key === 'Enter' && checkPassword()}
                                style={{padding: '15px', fontSize: '16px', width: '100%', maxWidth: '300px', marginBottom: '15px', borderRadius: '10px', border: '2px solid #667eea'}}
                            />
                            {passwordError && <p style={{color: 'red', marginBottom: '15px'}}>{passwordError}</p>}
                            <br/>
                            <button className="start-btn" style={{maxWidth: '300px'}} onClick={checkPassword}>Access</button>
                        </div>
                    </div>
                );
            }

            // API KEY SCREEN
            if (showApiPrompt) {
                return (
                    <div className="container">
                        <div className="header">
                            <h1>üîë API Key Required</h1>
                            <p>Enter your OpenAI API key</p>
                        </div>
                        <div className="content" style={{textAlign: 'center'}}>
                            <input 
                                type="password"
                                placeholder="sk-proj-..."
                                value={apiKey}
                                onChange={(e) => setApiKey(e.target.value)}
                                style={{padding: '15px', fontSize: '16px', width: '100%', marginBottom: '15px', borderRadius: '10px', border: '2px solid #667eea'}}
                            />
                            <button className="start-btn" onClick={saveApiKey} disabled={!apiKey}>Save & Continue</button>
                            <p style={{marginTop: '20px', color: '#666'}}>
                                Get key at <a href="https://platform.openai.com/api-keys" target="_blank">platform.openai.com</a>
                            </p>
                        </div>
                    </div>
                );
            }

            // SETUP SCREEN
            if (gameState === 'setup') {
                const canStart = difficulty && officeName && doctorName && firstVisitCost;
                
                return (
                    <div className="container">
                        <div className="header">
                            <h1>üé§ Chiro Voice Training 2.0</h1>
                            <p>Practice handling patient calls</p>
                        </div>
                        <div className="content">
                            <h3 style={{marginBottom: '20px'}}>Clinic Information:</h3>
                            
                            <div className="form-row">
                                <div className="form-group">
                                    <label>Office Name *</label>
                                    <input 
                                        type="text"
                                        placeholder="Brighton Spine & Wellness"
                                        value={officeName}
                                        onChange={(e) => setOfficeName(e.target.value)}
                                    />
                                </div>
                                <div className="form-group">
                                    <label>Doctor Name *</label>
                                    <input 
                                        type="text"
                                        placeholder="Smith"
                                        value={doctorName}
                                        onChange={(e) => setDoctorName(e.target.value)}
                                    />
                                </div>
                            </div>
                            
                            <div className="form-row">
                                <div className="form-group">
                                    <label>First Visit Cost ($) *</label>
                                    <input 
                                        type="number"
                                        placeholder="59"
                                        value={firstVisitCost}
                                        onChange={(e) => setFirstVisitCost(e.target.value)}
                                    />
                                </div>
                                <div className="form-group">
                                    <label>Your Name (VA)</label>
                                    <input 
                                        type="text"
                                        placeholder="Optional"
                                        value={vaName}
                                        onChange={(e) => setVaName(e.target.value)}
                                    />
                                </div>
                            </div>
                            
                            <h3 style={{marginBottom: '20px', marginTop: '30px'}}>Select Difficulty:</h3>
                            <div className="difficulty-grid">
                                <div className={`difficulty-btn ${difficulty === 'easy' ? 'selected' : ''}`} onClick={() => setDifficulty('easy')}>
                                    <div style={{fontSize: '24px'}}>üòä</div>
                                    <div><strong>Easy</strong></div>
                                    <div style={{fontSize: '12px'}}>Cooperative patient</div>
                                </div>
                                <div className={`difficulty-btn ${difficulty === 'challenging' ? 'selected' : ''}`} onClick={() => setDifficulty('challenging')}>
                                    <div style={{fontSize: '24px'}}>ü§î</div>
                                    <div><strong>Challenging</strong></div>
                                    <div style={{fontSize: '12px'}}>Price-conscious</div>
                                </div>
                                <div className={`difficulty-btn ${difficulty === 'difficult' ? 'selected' : ''}`} onClick={() => setDifficulty('difficult')}>
                                    <div style={{fontSize: '24px'}}>üò§</div>
                                    <div><strong>Skeptical</strong></div>
                                    <div style={{fontSize: '12px'}}>Needs convincing</div>
                                </div>
                                <div className={`difficulty-btn ${difficulty === 'creepy' ? 'selected' : ''}`} onClick={() => setDifficulty('creepy')}>
                                    <div style={{fontSize: '24px'}}>üòà</div>
                                    <div><strong>Creepy</strong></div>
                                    <div style={{fontSize: '12px'}}>Inappropriate caller</div>
                                </div>
                            </div>
                            <button className="start-btn" onClick={startCall} disabled={!canStart}>
                                {canStart ? 'Start Call' : 'Fill in all fields'}
                            </button>
                        </div>
                    </div>
                );
            }

            // PLAYING SCREEN
            if (gameState === 'playing') {
                return (
                    <div className="container">
                        <div className="header">
                            <h1>üìû Call In Progress</h1>
                            <p>{officeName} - {difficulty.charAt(0).toUpperCase() + difficulty.slice(1)} Mode</p>
                        </div>
                        <div className="content">
                            <div className={`status-box ${currentStatus === 'waiting' ? 'status-waiting' : `status-${currentStatus}`}`}>
                                {currentStatus === 'listening' && 'üé§ Listening to you...'}
                                {currentStatus === 'speaking' && 'üîä Patient speaking...'}
                                {currentStatus === 'thinking' && 'üí≠ Processing...'}
                                {currentStatus === 'idle' && '‚è∏Ô∏è Ready'}
                            </div>
                            
                            {interimText && (
                                <div style={{padding: '10px', background: '#f0f0f0', borderRadius: '8px', marginBottom: '15px', fontStyle: 'italic'}}>
                                    Hearing: "{interimText}"
                                </div>
                            )}
                            
                            <div className="chat-container">
                                {messages.map((msg, i) => (
                                    <div key={i} className={`message ${msg.type}`}>
                                        {msg.type === 'staff' && <strong>You: </strong>}
                                        {msg.type === 'patient' && <strong>Patient: </strong>}
                                        {msg.text}
                                    </div>
                                ))}
                            </div>
                            
                            <button className="end-call-btn" onClick={endCall}>
                                ‚èπÔ∏è End Call & Get Score
                            </button>
                            
                            {/* Debug toggle */}
                            <div style={{marginTop: '15px', textAlign: 'center'}}>
                                <button 
                                    onClick={() => setShowDebug(!showDebug)}
                                    style={{background: 'none', border: 'none', color: '#999', cursor: 'pointer', fontSize: '12px'}}
                                >
                                    {showDebug ? 'Hide Debug' : 'Show Debug'}
                                </button>
                            </div>
                            
                            {showDebug && (
                                <div className="debug-panel">
                                    <strong>Debug Info:</strong>
                                    <pre>
                                        Turn: {turnCount}{'\n'}
                                        Conversation: {JSON.stringify(conversationRef.current, null, 2)}
                                    </pre>
                                </div>
                            )}
                        </div>
                    </div>
                );
            }

            // SCORING SCREEN
            if (gameState === 'scoring') {
                // Creepy mode result
                if (scoreData.isCreepy) {
                    return (
                        <div className="container">
                            <div className="header">
                                <h1>üö® Creepy Caller Result</h1>
                            </div>
                            <div className="content">
                                <div className="score-card">
                                    <div className="overall-score" style={{color: scoreData.passed ? '#4caf50' : '#ff9800'}}>
                                        {scoreData.result}
                                    </div>
                                    <p style={{textAlign: 'center', fontSize: '18px'}}>{scoreData.feedback}</p>
                                </div>
                                <button className="start-btn" onClick={resetGame} style={{marginTop: '20px'}}>Try Again</button>
                            </div>
                        </div>
                    );
                }

                // Regular scoring
                const checkpointTotal = Object.values(scoreData.scores).reduce((sum, c) => sum + c.score, 0);
                const passed = scoreData.totalScore >= 70;

                return (
                    <div className="container">
                        <div className="header">
                            <h1>üìä Your Score</h1>
                            <p>{passed ? '‚úÖ PASSED' : '‚ùå NEEDS IMPROVEMENT'}</p>
                        </div>
                        <div className="content">
                            <div className="score-card">
                                <div className="overall-score" style={{color: passed ? '#4caf50' : '#f44336'}}>
                                    {scoreData.totalScore}/100
                                </div>
                                
                                {/* Booking Status */}
                                <div style={{textAlign: 'center', marginBottom: '20px', padding: '15px', background: scoreData.patientBooked ? '#e8f5e9' : '#ffebee', borderRadius: '10px'}}>
                                    <strong>{scoreData.patientBooked ? '‚úÖ Patient Booked!' : '‚ùå Patient Did Not Book'}</strong>
                                </div>
                                
                                {/* Summary */}
                                {scoreData.summary && (
                                    <div style={{marginBottom: '20px', padding: '15px', background: '#f5f5f5', borderRadius: '10px'}}>
                                        <strong>Summary:</strong> {scoreData.summary}
                                    </div>
                                )}
                                
                                <h3 style={{marginBottom: '15px'}}>7 Checkpoints ({checkpointTotal}/70):</h3>
                                
                                {Object.entries(scoreData.scores).map(([key, data]) => {
                                    const labels = {
                                        greeting: 'Greeting & Introduction',
                                        reason: 'Identified Reason for Call',
                                        scheduling: 'Scheduling & Time',
                                        patientInfo: 'Collected Patient Info',
                                        referral: 'Asked Referral Source',
                                        feeExplanation: 'Explained Fee & Inclusions',
                                        closing: 'Professional Closing'
                                    };
                                    
                                    return (
                                        <div key={key} className="score-item" style={{background: data.score >= 7 ? '#e8f5e9' : data.score >= 4 ? '#fff3e0' : '#ffebee'}}>
                                            <div style={{display: 'flex', justifyContent: 'space-between', alignItems: 'center'}}>
                                                <span>
                                                    {data.score >= 7 ? '‚úÖ' : data.score >= 4 ? '‚ö†Ô∏è' : '‚ùå'} {labels[key]}
                                                </span>
                                                <strong>{data.score}/10</strong>
                                            </div>
                                            {data.note && <p style={{fontSize: '13px', color: '#666', marginTop: '5px'}}>{data.note}</p>}
                                        </div>
                                    );
                                })}
                                
                                <div style={{marginTop: '15px', padding: '15px', background: '#f5f5f5', borderRadius: '10px'}}>
                                    <strong>Bonus Points:</strong> {scoreData.bonus}/30
                                </div>
                                
                                {/* Feedback sections */}
                                {scoreData.positives && scoreData.positives.length > 0 && scoreData.positives[0] && (
                                    <div className="feedback-section">
                                        <h4 className="positive">‚úÖ What You Did Well:</h4>
                                        <ul>
                                            {scoreData.positives.filter(p => p).map((item, i) => (
                                                <li key={i}>{item}</li>
                                            ))}
                                        </ul>
                                    </div>
                                )}
                                
                                {scoreData.improvements && scoreData.improvements.length > 0 && scoreData.improvements[0] && (
                                    <div className="feedback-section">
                                        <h4 className="negative">üìà Areas to Improve:</h4>
                                        <ul>
                                            {scoreData.improvements.filter(p => p).map((item, i) => (
                                                <li key={i}>{item}</li>
                                            ))}
                                        </ul>
                                    </div>
                                )}
                                
                                {scoreData.criticalMisses && scoreData.criticalMisses.length > 0 && scoreData.criticalMisses[0] && (
                                    <div className="feedback-section" style={{background: '#ffebee'}}>
                                        <h4 className="critical">üö® Critical Misses:</h4>
                                        <ul>
                                            {scoreData.criticalMisses.filter(p => p).map((item, i) => (
                                                <li key={i}>{item}</li>
                                            ))}
                                        </ul>
                                    </div>
                                )}
                            </div>
                            
                            <button className="start-btn" onClick={resetGame} style={{marginTop: '20px'}}>Try Another Call</button>
                        </div>
                    </div>
                );
            }

            return null;
        }

        ReactDOM.render(<ChiroVoiceTrainer />, document.getElementById('root'));
    </script>
</body>
</html>
